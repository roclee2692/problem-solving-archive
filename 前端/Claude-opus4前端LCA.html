<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LCA倍增算法可视化</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #333;
        }
        .input-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }
        .input-group {
            margin-bottom: 10px;
        }
        label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        input, textarea {
            padding: 5px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        #tree-canvas {
            border: 1px solid #ddd;
            margin: 20px 0;
            display: block;
        }
        .table-container {
            margin: 20px 0;
            overflow-x: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        .highlight {
            background-color: #ffeb3b !important;
            font-weight: bold;
        }
        .path-highlight {
            background-color: #ff9800 !important;
            color: white;
        }
        .lca-highlight {
            background-color: #f44336 !important;
            color: white;
        }
        .step-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 5px;
            font-family: monospace;
        }
        .legend {
            margin: 20px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        .legend-item {
            display: inline-block;
            margin-right: 20px;
        }
        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            vertical-align: middle;
            border: 1px solid #333;
        }
        .query-section {
            margin-top: 30px;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 5px;
        }
        .animation-controls {
            margin: 20px 0;
        }
        #speed-slider {
            width: 200px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LCA（最近公共祖先）倍增算法可视化</h1>
        
        <div class="input-section">
            <h2>输入数据</h2>
            <div class="input-group">
                <label>节点数 (n):</label>
                <input type="number" id="n" value="7" min="2" max="20">
            </div>
            <div class="input-group">
                <label>根节点 (s):</label>
                <input type="number" id="s" value="1" min="1">
            </div>
            <div class="input-group">
                <label>边列表 (格式: u v):</label><br>
                <textarea id="edges" rows="6" cols="30">1 2
1 3
2 4
2 5
3 6
3 7</textarea>
            </div>
            <button onclick="buildTree()">构建树并初始化</button>
            <button onclick="runDFS()">执行DFS预处理</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <span class="legend-color" style="background-color: #4CAF50;"></span>
                <span>普通节点</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #ffeb3b;"></span>
                <span>当前处理节点</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #ff9800;"></span>
                <span>查询路径</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #f44336;"></span>
                <span>LCA节点</span>
            </div>
        </div>

        <h2>树的可视化</h2>
        <canvas id="tree-canvas" width="800" height="400"></canvas>

        <div class="animation-controls">
            <label>动画速度:</label>
            <input type="range" id="speed-slider" min="100" max="2000" value="500" step="100">
            <span id="speed-value">500ms</span>
        </div>

        <h2>倍增表 up[u][j] - 节点u向上跳2^j步到达的祖先</h2>
        <div class="table-container">
            <table id="up-table">
                <thead>
                    <tr>
                        <th>节点\2^j</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <h2>深度表 depth[u]</h2>
        <div class="table-container">
            <table id="depth-table">
                <thead>
                    <tr id="depth-header">
                        <th>节点</th>
                    </tr>
                </thead>
                <tbody>
                    <tr id="depth-values">
                        <th>深度</th>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="step-info" id="step-info">
            等待初始化...
        </div>

        <div class="query-section">
            <h2>LCA查询</h2>
            <div class="input-group">
                <label>节点A:</label>
                <input type="number" id="query-a" value="4" min="1">
                <label>节点B:</label>
                <input type="number" id="query-b" value="7" min="1">
                <button onclick="queryLCA()">查询LCA</button>
            </div>
            <div class="step-info" id="query-info">
                等待查询...
            </div>
        </div>
    </div>

    <script>
        let n, s;
        let adj = {};
        let up = {};
        let depth = {};
        let maxE = {};
        let dist = {};
        let LOGN = 5;
        let animationSpeed = 500;
        let treePositions = {};

        document.getElementById('speed-slider').addEventListener('input', function(e) {
            animationSpeed = parseInt(e.target.value);
            document.getElementById('speed-value').textContent = animationSpeed + 'ms';
        });

        function buildTree() {
            n = parseInt(document.getElementById('n').value);
            s = parseInt(document.getElementById('s').value);
            
            // 初始化邻接表
            adj = {};
            for (let i = 1; i <= n; i++) {
                adj[i] = [];
            }
            
            // 读取边
            const edgesText = document.getElementById('edges').value.trim();
            const lines = edgesText.split('\n');
            
            for (let line of lines) {
                const [u, v] = line.trim().split(' ').map(Number);
                adj[u].push({v: v, w: 1});
                adj[v].push({v: u, w: 1});
            }
            
            // 初始化数组
            for (let i = 1; i <= n; i++) {
                up[i] = new Array(LOGN + 1).fill(0);
                maxE[i] = new Array(LOGN + 1).fill(0);
                depth[i] = 0;
                dist[i] = 0;
            }
            
            drawTree();
            initializeTables();
            updateStepInfo("树已构建，等待执行DFS预处理...");
        }

        function calculateTreePositions(node, parent, x, y, level, width) {
            treePositions[node] = {x, y};
            
            const children = adj[node].filter(e => e.v !== parent);
            const childCount = children.length;
            
            if (childCount === 0) return;
            
            const childWidth = width / childCount;
            let childX = x - width / 2 + childWidth / 2;
            
            children.forEach(edge => {
                calculateTreePositions(edge.v, node, childX, y + 80, level + 1, childWidth);
                childX += childWidth;
            });
        }

        function drawTree() {
            const canvas = document.getElementById('tree-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 计算树的位置
            treePositions = {};
            calculateTreePositions(s, 0, canvas.width / 2, 50, 0, canvas.width - 100);
            
            // 绘制边
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            for (let u = 1; u <= n; u++) {
                if (!treePositions[u]) continue;
                for (let edge of adj[u]) {
                    let v = edge.v;
                    if (!treePositions[v]) continue;
                    if (depth[v] > depth[u] || (depth[v] === 0 && depth[u] === 0 && u < v)) {
                        ctx.beginPath();
                        ctx.moveTo(treePositions[u].x, treePositions[u].y);
                        ctx.lineTo(treePositions[v].x, treePositions[v].y);
                        ctx.stroke();
                    }
                }
            }
            
            // 绘制节点
            for (let i = 1; i <= n; i++) {
                if (!treePositions[i]) continue;
                drawNode(ctx, i, '#4CAF50');
            }
        }

        function drawNode(ctx, node, color) {
            if (!treePositions[node]) return;
            
            const pos = treePositions[node];
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node, pos.x, pos.y);
        }

        function highlightNode(node, color) {
            const canvas = document.getElementById('tree-canvas');
            const ctx = canvas.getContext('2d');
            drawNode(ctx, node, color);
        }

        function initializeTables() {
            // 初始化up表
            const upTable = document.getElementById('up-table');
            const thead = upTable.querySelector('thead tr');
            thead.innerHTML = '<th>节点\\2^j</th>';
            
            for (let j = 0; j <= LOGN; j++) {
                thead.innerHTML += `<th>2^${j}=${1<<j}</th>`;
            }
            
            const tbody = upTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            for (let i = 1; i <= n; i++) {
                let row = '<tr><th>' + i + '</th>';
                for (let j = 0; j <= LOGN; j++) {
                    row += `<td id="up-${i}-${j}">-</td>`;
                }
                row += '</tr>';
                tbody.innerHTML += row;
            }
            
            // 初始化深度表
            const depthHeader = document.getElementById('depth-header');
            const depthValues = document.getElementById('depth-values');
            
            depthHeader.innerHTML = '<th>节点</th>';
            depthValues.innerHTML = '<th>深度</th>';
            
            for (let i = 1; i <= n; i++) {
                depthHeader.innerHTML += `<th>${i}</th>`;
                depthValues.innerHTML += `<td id="depth-${i}">-</td>`;
            }
        }

        async function runDFS() {
            updateStepInfo("开始DFS预处理...");
            await dfs(s, 0);
            updateStepInfo("DFS预处理完成！");
        }

        async function dfs(u, parent) {
            // 高亮当前节点
            highlightNode(u, '#ffeb3b');
            
            // 更新深度
            depth[u] = parent === 0 ? 1 : depth[parent] + 1;
            document.getElementById(`depth-${u}`).textContent = depth[u];
            document.getElementById(`depth-${u}`).classList.add('highlight');
            
            await sleep(animationSpeed);
            
            // 更新up表
            up[u][0] = parent;
            if (parent !== 0) {
                document.getElementById(`up-${u}-0`).textContent = parent;
                document.getElementById(`up-${u}-0`).classList.add('highlight');
                await sleep(animationSpeed / 2);
            }
            
            // 倍增预处理
            for (let i = 1; i <= LOGN; i++) {
                if (up[u][i-1] === 0) break;
                up[u][i] = up[up[u][i-1]][i-1];
                
                if (up[u][i] !== 0) {
                    document.getElementById(`up-${u}-${i}`).textContent = up[u][i];
                    document.getElementById(`up-${u}-${i}`).classList.add('highlight');
                    
                    updateStepInfo(`节点${u}: up[${u}][${i}] = up[up[${u}][${i-1}]][${i-1}] = up[${up[u][i-1]}][${i-1}] = ${up[u][i]}`);
                    await sleep(animationSpeed);
                }
            }
            
            // 移除高亮
            for (let i = 0; i <= LOGN; i++) {
                const cell = document.getElementById(`up-${u}-${i}`);
                if (cell) cell.classList.remove('highlight');
            }
            document.getElementById(`depth-${u}`).classList.remove('highlight');
            
            // 递归处理子节点
            for (let edge of adj[u]) {
                if (edge.v === parent) continue;
                dist[edge.v] = dist[u] + edge.w;
                await dfs(edge.v, u);
            }
            
            // 恢复节点颜色
            highlightNode(u, '#4CAF50');
        }

        async function queryLCA() {
            let a = parseInt(document.getElementById('query-a').value);
            let b = parseInt(document.getElementById('query-b').value);
            
            updateQueryInfo(`开始查询LCA(${a}, ${b})...`);
            
            // 清除之前的高亮
            drawTree();
            
            // 高亮查询的两个节点
            highlightNode(a, '#ff9800');
            highlightNode(b, '#ff9800');
            await sleep(animationSpeed);
            
            let x = a, y = b;
            
            // 第一步：让深度相同
            if (depth[x] < depth[y]) {
                [x, y] = [y, x];
            }
            
            updateQueryInfo(`调整深度: depth[${x}]=${depth[x]}, depth[${y}]=${depth[y]}`);
            
            let diff = depth[x] - depth[y];
            updateQueryInfo(`深度差 = ${diff}`);
            await sleep(animationSpeed);
            
            // 跳跃使深度相同
            for (let i = 0; i <= LOGN; i++) {
                if (diff & (1 << i)) {
                    updateQueryInfo(`${x} 向上跳 2^${i}=${1<<i} 步到 ${up[x][i]}`);
                    highlightNode(x, '#4CAF50');
                    x = up[x][i];
                    highlightNode(x, '#ff9800');
                    await sleep(animationSpeed);
                }
            }
            
            if (x === y) {
                highlightNode(x, '#f44336');
                updateQueryInfo(`LCA(${a}, ${b}) = ${x}`);
                return;
            }
            
            // 第二步：二进制跳跃找LCA
            updateQueryInfo(`深度相同后: x=${x}, y=${y}，开始二进制跳跃`);
            await sleep(animationSpeed);
            
            for (let i = LOGN; i >= 0; i--) {
                if (up[x][i] !== up[y][i] && up[x][i] !== 0) {
                    updateQueryInfo(`尝试跳 2^${i}=${1<<i} 步: up[${x}][${i}]=${up[x][i]}, up[${y}][${i}]=${up[y][i]} (不同，跳跃)`);
                    
                    highlightNode(x, '#4CAF50');
                    highlightNode(y, '#4CAF50');
                    
                    x = up[x][i];
                    y = up[y][i];
                    
                    highlightNode(x, '#ff9800');
                    highlightNode(y, '#ff9800');
                    await sleep(animationSpeed);
                }
            }
            
            let lca = up[x][0];
            highlightNode(lca, '#f44336');
            updateQueryInfo(`LCA(${a}, ${b}) = ${lca}`);
        }

        function updateStepInfo(text) {
            document.getElementById('step-info').textContent = text;
        }

        function updateQueryInfo(text) {
            const info = document.getElementById('query-info');
            info.innerHTML += text + '<br>';
            info.scrollTop = info.scrollHeight;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // 初始化
        window.onload = function() {
            buildTree();
        };
    </script>
</body>
</html>