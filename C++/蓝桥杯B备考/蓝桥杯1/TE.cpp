#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
ll lcm(ll a,ll b){return a*b/gcd(a,b);}
int main(){
    int n;
    cin>>n;//宝石个数
    vector<int> H(n);
    for(auto &x:H){
      cin>>x;
    }
     sort(H.begin(),H.end());
     ll mx=-1,a,b,c;//mx存储最大值的变量必须提前开好，不能在函数作用域中声明，因为每次循环变量都会更新
     int st= max(0, n - 50);//如果数据量小于50个直接从0开始遍历，防止出现n-50为负
     //st是为例记录宝石第50个最大值的出现索引
     /*
========================【关键注释 - 必看】========================
1. 为什么 `int st = max(0, n - 50);` 是正确的？
   - 如果 `n >= 50`，`st = n - 50`，从倒数第 50 个元素开始枚举，确保只用最大值进行组合。
   - 如果 `n < 50`，`st = 0`，确保从第一个元素开始枚举，不会出现负下标访问错误。
   
2. 为什么要写成 `i < n` 而不是 `i <= n`？
   - 数组最大索引是 `n - 1`，写成 `i <= n` 会越界访问 `H[n]`，导致程序崩溃。
你用了数组，索引是从0开始的，不写等于刚刚好
3. 为什么三重循环写成 `j = i + 1; k = j + 1;` 而不是 `j = st + 1; k = st + 2;`？
   - 必须保证三重循环的每一个组合是唯一的、递增的，不重不漏。
   - 用 `j = st + 1; k = st + 2;` 会导致大量重复计算或遗漏组合。
==================================================================
*/
/*
================【组合唯一性原理】================
1. `k = j + 1` 确保索引严格递增：`i < j < k`。
2. 每次递增都在前一个基础上拓展，绝不会回头或重用。
3. 索引限制由 `k` 决定，确保所有组合唯一且不重叠。
=================================================
*/
     for(int i=st;i<n;i++){//第一层for循环遍历
        for(int j=i+1;j<n;j++){
          for(int k=j+1;k<n;k++){
            ll Ha=H[i],Hb=H[j],Hc=H[k];
              ll L=lcm(Ha,lcm(Hb,Hc));
              ll S=Ha*Hb*Hc*L/lcm(Ha,Hb)/lcm(Ha,Hc)/lcm(Hb,Hc);
              if(S>mx) mx=S,a=Ha,b=Hb,c=Hc;//mx存储最大值的变量必须提前开好，a,b,c同理，不能在函数作用域中声明，因为每次循环变量都会更新
              //这样同时也保证了，有相同S时取得是按照H值升序排序后的最小方案  
          }
        }
      } 
    cout<<a<<" "<<b<<" "<<c<<endl;
   return 0;
}