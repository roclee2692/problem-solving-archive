/*
 * 【中国剩余定理 CRT】- 求解同余方程组
 * 
 * 时间复杂度：O(k log m)，k = 方程个数，m = 模数最大值
 * 空间复杂度：O(k)
 * 
 * 适用场景：
 *   - 求解 x ≡ a_i (mod m_i) 的同余方程组
 *   - 前提：所有 m_i 两两互质
 *   - 扩展 CRT：m_i 不互质时
 * 
 * 【什么是中国剩余定理？】
 * 古代问题："今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？"
 * 翻译：求 x 满足 x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)
 * 答案：x = 23
 * 
 * 【核心思想】
 * 构造法：分别构造只满足一个方程、对其他方程贡献为 0 的特解，然后加起来。
 * 
 * 模板题：
 *   - 洛谷 P1495 - 【模板】中国剩余定理(CRT)/曾经沧海
 *   - Codeforces 1106F - Lunar New Year and a Recursive Sequence
 */

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

// ===== 扩展欧几里得：求 ax + by = gcd(a, b) 的解 =====

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    ll x1, y1;
    ll d = exgcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - a / b * y1;
    return d;
}


// ===== 中国剩余定理（互质版本）=====
// 问题：求 x 满足 x ≡ a[i] (mod m[i])，其中所有 m[i] 两两互质
// 返回 {解 x, 大模数 M}
//
// 【核心思想：分而治之的构造法】
// 我们想找一个 x 同时满足 n 个方程，直接找很难。
// 那么能不能"各个击破"——先找只满足第 1 个方程的 x₁，再找只满足第 2 个的 x₂...
// 然后把它们加起来：x = x₁ + x₂ + ... + xₙ？
//
// 【问题】如何保证 x₁ 只对第 1 个方程有贡献？
// 关键：让 x₁ 对其他方程"透明"（贡献为 0）！
//
// 【解决方案】
// 1. 令 M = m[0] × m[1] × ... × m[n-1]（所有模数的乘积）
// 2. 对于第 i 个方程，构造特解 xᵢ：
//    
//    令 M_i = M / m[i] = m[0] × ... × m[i-1] × m[i+1] × ... × m[n-1]
//    （M_i 是除了 m[i] 外所有模数的乘积）
//    
//    关键观察：
//    - M_i 包含 m[j] (j≠i) 作为因子 → M_i ≡ 0 (mod m[j]) ✓ 对其他方程透明！
//    - M_i 不包含 m[i] 作为因子 → M_i 与 m[i] 互质 → 存在逆元 tᵢ 使 M_i × tᵢ ≡ 1 (mod m[i])
//    
//    因此令 xᵢ = a[i] × M_i × tᵢ：
//    - xᵢ ≡ a[i] × 1 = a[i] (mod m[i]) ✓ 满足第 i 个方程！
//    - xᵢ ≡ a[i] × 0 × tᵢ = 0 (mod m[j]), j≠i ✓ 对其他方程没影响！
//
// 3. 最终答案：x = (x₁ + x₂ + ... + xₙ) mod M
//    每一项只对自己的方程有贡献，叠加后同时满足所有方程！
//    
//    【为什么解相差 M 的倍数？核心证明】
//    
//    假设 x₀ 是一个解，即：
//      x₀ ≡ a[0] (mod m[0])
//      x₀ ≡ a[1] (mod m[1])
//      ...
//      x₀ ≡ a[n-1] (mod m[n-1])
//    
//    现在证明 x₀ + M 也是解（其中 M = m[0] × m[1] × ... × m[n-1]）：
//    
//    对于第 i 个方程：
//      (x₀ + M) mod m[i] 
//      = (x₀ mod m[i] + M mod m[i]) mod m[i]    ← 模运算的加法性质
//      = (a[i] + M mod m[i]) mod m[i]           ← x₀ 满足第 i 个方程
//      = (a[i] + 0) mod m[i]                     ← 关键！M 包含 m[i] 作为因子，所以 M ≡ 0 (mod m[i])
//      = a[i]                                    ← 所以 x₀ + M 也满足第 i 个方程！
//    
//    同理，x₀ + 2M, x₀ + 3M, ... 都满足所有方程。
//    x₀ - M, x₀ - 2M, ... 也都满足（负数解）。
//    
//    【为什么不能相差比 M 小的数？】
//    
//    假设存在 d < M，使得 x₀ 和 x₀ + d 都满足所有方程：
//      x₀ ≡ a[i] (mod m[i])
//      x₀ + d ≡ a[i] (mod m[i])
//    
//    两式相减：d ≡ 0 (mod m[i])，即 d 是 m[i] 的倍数。
//    
//    这对所有 i 都成立，所以 d 是 m[0], m[1], ..., m[n-1] 的公倍数。
//    而 M = lcm(m[0], m[1], ..., m[n-1]) 是最小公倍数（互质时等于乘积）。
//    所以 d ≥ M，矛盾！
//    
//    结论：通解必须相差 M 的倍数，不能更小！
//    
//    【例子验证】
//    x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)
//    M = 3 × 5 × 7 = 105
//    
//    解：23, 128, 233, 338, ... （相差 105）
//    验证 23 + 105 = 128：
//      128 mod 3 = 2 ✓
//      128 mod 5 = 3 ✓
//      128 mod 7 = 2 ✓
//    
//    % M 的作用：把无穷多个解 {..., -82, 23, 128, 233, ...} 标准化到 [0, M) 区间取代表元
//
// 【具体例子】
// 求 x 满足：x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)
//
// M = 3 × 5 × 7 = 105
//
// 第 1 个方程 (x ≡ 2 (mod 3))：
//   M₁ = 105/3 = 35 = 5×7
//   35 ≡ 2 (mod 3)，逆元 t₁ = 2（因为 2×2 = 4 ≡ 1 (mod 3)）
//   x₁ = 2 × 35 × 2 = 140
//   验证：140 ≡ 2 (mod 3) ✓，140 ≡ 0 (mod 5) ✓，140 ≡ 0 (mod 7) ✓
//
// 第 2 个方程 (x ≡ 3 (mod 5))：
//   M₂ = 105/5 = 21 = 3×7
//   21 ≡ 1 (mod 5)，逆元 t₂ = 1（因为 1×1 = 1 ≡ 1 (mod 5)）
//   x₂ = 3 × 21 × 1 = 63
//   验证：63 ≡ 0 (mod 3) ✓，63 ≡ 3 (mod 5) ✓，63 ≡ 0 (mod 7) ✓
//
// 第 3 个方程 (x ≡ 2 (mod 7))：
//   M₃ = 105/7 = 15 = 3×5
//   15 ≡ 1 (mod 7)，逆元 t₃ = 1（因为 1×1 = 1 ≡ 1 (mod 7)）
//   x₃ = 2 × 15 × 1 = 30
//   验证：30 ≡ 0 (mod 3) ✓，30 ≡ 0 (mod 5) ✓，30 ≡ 2 (mod 7) ✓
//
// 答案：x = (140 + 63 + 30) mod 105 = 233 mod 105 = 23
// 验证：23 ≡ 2 (mod 3) ✓，23 ≡ 3 (mod 5) ✓，23 ≡ 2 (mod 7) ✓
//
// 【为什么一定要互质？】
// 如果 m[i] 和 m[j] 不互质，M_i 可能与 m[i] 也不互质 → 逆元不存在！
// 此时需要用扩展 CRT（见 extgcd_merge 函数）
pair<ll, ll> crt(vector<ll> &a, vector<ll> &m) {
    int n = a.size();
    ll M = 1, ans = 0;
    
    // 步骤 1：计算所有模数的乘积 M
    for (int i = 0; i < n; i++) {
        M *= m[i];
    }
    
    // 步骤 2：对每个方程，构造只满足它的特解，累加到答案
    for (int i = 0; i < n; i++) {
        ll Mi = M / m[i];  // M_i = 除了 m[i] 外所有模数的乘积
        
        // 步骤 3：用扩展欧几里得求 M_i 在 mod m[i] 下的逆元
        // 即求 x 满足 M_i * x ≡ 1 (mod m[i])
        ll x, y;
        exgcd(Mi, m[i], x, y);
        x = (x % m[i] + m[i]) % m[i];  // 防止负数
        
        // 步骤 4：累加这一项的贡献 a[i] * M_i * t_i
        ans = (ans + a[i] * Mi % M * x % M) % M;
    }
    
    return {ans, M};
}

// ===== 扩展中国剩余定理（非互质版本）=====
// 当模数不互质时，不能直接用上面的公式
// 方法：把方程两两合并
//
// 【问题】
// 给定两个方程：
//   x ≡ a₁ (mod m₁)  →  x = a₁ + k₁ × m₁ (k₁ 是整数)
//   x ≡ a₂ (mod m₂)  →  x = a₂ + k₂ × m₂ (k₂ 是整数)
// 目标：合并成一个方程 x ≡ a (mod M)
//
// 【推导过程】
// 1. 因为两个式子都等于 x，所以：
//    a₁ + k₁×m₁ = a₂ + k₂×m₂
//
// 2. 移项整理：
//    k₁×m₁ - k₂×m₂ = a₂ - a₁
//
// 3. 这是一个不定方程！形如 Ax + By = C
//    回忆 exgcd：我们可以求解 k₁×m₁ + k₂×(-m₂) = a₂ - a₁
//    
//    【注意】这里 k₂ 前面有负号，但没关系！
//    - exgcd 求解的是 m₁×x + m₂×y = gcd(m₁, m₂)
//    - 我们需要的是 m₁×k₁ + (-m₂)×k₂ = a₂ - a₁
//    - 令 a = m₁, b = m₂，照样调用 exgcd(a, b, x, y) 即可
//    - GCD 的性质：gcd(a, b) = gcd(a, -b) = gcd(|a|, |b|)，永远返回正数
//
// 4. 有解条件：根据贝祖定理，(a₂ - a₁) 必须是 gcd(m₁, m₂) 的倍数
//    如果 (a₂ - a₁) % gcd(m₁, m₂) ≠ 0 → 无解！
//    
//    【为什么？】贝祖定理说：ax + by 能表示的最小正整数是 gcd(a, b)
//    换句话说，ax + by 只能取 gcd(a, b) 的倍数！
//    所以如果 (a₂ - a₁) 不是 gcd(m₁, m₂) 的倍数，方程无整数解
//
// 5. 用 exgcd 求出一组特解 k₁：
//    x = a₁ + k₁×m₁ 就是两个方程的公共解
//
// 6. 通解是什么？
//    k₁ 可以加上任意 m₂/gcd(m₁,m₂) 的倍数，x 仍然满足两个方程
//    所以合并后的方程是：x ≡ (a₁ + k₁×m₁) (mod lcm(m₁, m₂))
//    其中 lcm(m₁, m₂) = m₁ × m₂ / gcd(m₁, m₂)
//
// 【具体例子】
// 合并：x ≡ 2 (mod 4), x ≡ 3 (mod 6)
//
// 1. x = 2 + k₁×4 = 3 + k₂×6
//    → 4k₁ - 6k₂ = 1
//
// 2. gcd(4, 6) = 2，检查：1 % 2 = 1 ≠ 0 → 无解！
//    (因为 2 和 3 模它们 gcd 的余数不同)
//
// 换个例子：x ≡ 2 (mod 4), x ≡ 2 (mod 6)
//
// 1. x = 2 + k₁×4 = 2 + k₂×6
//    → 4k₁ - 6k₂ = 0
//
// 2. gcd(4, 6) = 2，检查：0 % 2 = 0 ✓ 有解
//
// 3. 用 exgcd 求解 4k₁ - 6k₂ = 0：
//    显然 k₁ = 0 是一个解
//    x = 2 + 0×4 = 2
//
// 4. 通解：x ≡ 2 (mod lcm(4,6)) = 2 (mod 12)
//    验证：2 ≡ 2 (mod 4) ✓, 2 ≡ 2 (mod 6) ✓
//    14 ≡ 2 (mod 4) ✓, 14 ≡ 2 (mod 6) ✓
//    26 ≡ 2 (mod 4) ✓, 26 ≡ 2 (mod 6) ✓
pair<ll, ll> extgcd_merge(ll a1, ll m1, ll a2, ll m2) {
    ll x, y;
    ll d = exgcd(m1, m2, x, y);  // 求 gcd 和系数
    
    // 检查是否有解：a2 - a1 必须是 gcd(m1, m2) 的倍数
    if ((a2 - a1) % d != 0) {
        return {-1, -1};  // 无解
    }
    
    // 新的模数是 lcm(m1, m2)
    ll lcm = m1 / d * m2;  // 先除后乘防溢出
    
    // 新的余数：a1 + k1 * m1，其中 k1 = x * (a2 - a1) / d
    ll a = (a1 + m1 * x % lcm * ((a2 - a1) / d) % lcm) % lcm;
    a = (a + lcm) % lcm;  // 防止负数
    
    return {a, lcm};
}

// ===== 扩展 CRT：合并多个方程 =====
// 逐个合并，最终得到一个方程
pair<ll, ll> excrt(vector<ll> &a, vector<ll> &m) {
    ll cur_a = a[0], cur_m = m[0];
    
    for (int i = 1; i < (int)a.size(); i++) {
        auto [new_a, new_m] = extgcd_merge(cur_a, cur_m, a[i], m[i]);
        if (new_m == -1) return {-1, -1};  // 无解
        cur_a = new_a;
        cur_m = new_m;
    }
    
    return {cur_a, cur_m};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<ll> a(n), m(n);
    for (int i = 0; i < n; i++) {
        cin >> m[i] >> a[i];  // 注意输入顺序：先模数后余数
    }
    
    auto [ans, M] = crt(a, m);  // 互质版本
    // auto [ans, M] = excrt(a, m);  // 非互质版本
    
    cout << ans << "\n";
    
    return 0;
}

/*
 * ========== 中国剩余定理核心原理 ==========
 * 
 * 【问题】
 * 求 x 满足：
 * x ≡ a[0] (mod m[0])
 * x ≡ a[1] (mod m[1])
 * ...
 * x ≡ a[n-1] (mod m[n-1])
 * 
 * 【互质 CRT 公式】
 * M = m[0] * m[1] * ... * m[n-1]
 * x = Σ(a[i] * M_i * inv(M_i, m[i])) mod M
 * 
 * 其中 M_i = M / m[i]，inv(M_i, m[i]) 是 M_i 在 mod m[i] 下的逆元
 * 
 * 【手算例子】
 * x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)
 * 
 * M = 3 * 5 * 7 = 105
 * M_0 = 35, inv(35, 3) = inv(2, 3) = 2  → 贡献 2 * 35 * 2 = 140
 * M_1 = 21, inv(21, 5) = inv(1, 5) = 1  → 贡献 3 * 21 * 1 = 63
 * M_2 = 15, inv(15, 7) = inv(1, 7) = 1  → 贡献 2 * 15 * 1 = 30
 * 
 * x = (140 + 63 + 30) % 105 = 233 % 105 = 23 ✓
 * 
 * 【非互质扩展 CRT】
 * 当模数不互质时，用 exgcd 逐两个合并
 * 合并 (a1, m1) 和 (a2, m2) 得到 (a_new, lcm(m1, m2))
 * 
 * 【关键点】
 * 1. 互质 CRT：M = ∏m_i, 答案 = Σ(a_i * M_i * (M_i^-1 mod m_i))
 * 2. M_i = M / m_i，需要计算其在 m_i 下的逆元
 * 3. 非互质 CRT：用扩展欧几里得逐两个合并
 * 4. 无解条件：(a2 - a1) % gcd(m1, m2) ≠ 0
 * 5. 合并后 lcm = m1 * m2 / gcd(m1, m2)
 * 
 * 【常见应用】
 * - 大数分解后分别求解再合并
 * - 求解模方程组（密码学）
 * - 区间内解计数
 * 
 * 【竞赛考察频率】
 * - NOI/省选：⭐⭐⭐⭐
 * - ICPC/CCPC：⭐⭐⭐
 * - Codeforces：⭐⭐（Div2 D/E）
 * 
 * 【提交前检查】
 * ✓ 互质性检查（或使用扩展版本）
 * ✓ 模逆元计算正确性
 * ✓ 取模防止溢出（先除后乘）
 * ✓ 无解条件判断
 * ✓ 负数取模处理
 */
