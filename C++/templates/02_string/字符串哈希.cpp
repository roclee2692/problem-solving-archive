/*
 * 【字符串哈希】- 竞赛标配模板
 * 
 * 核心思想：把字符串看作 B 进制数，转换为数值进行比较
 * 例如："abc" → a×B² + b×B¹ + c×B⁰
 * 
 * 时间复杂度：预处理 O(n)，查询 O(1)
 * 空间复杂度：O(n)
 * 
 * 适用：99% 的字符串匹配/判重/LCP 问题
 * 推荐基数：131、13331（经验值，分布均匀）
 */

#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;  // 必须用 ull，利用自然溢出（mod 2^64）
typedef long long ll;

// 【核心参数】
const ull B = 131;  // 进制基数（常用：131 或 13331）
                    // 原则：B > 字符集大小（ASCII=128，所以 B≥131）
                    // 为什么选 131？经验值，分布均匀，碰撞少

// 【全局数组】
vector<ull> H;      // H[i] = S[0..i-1] 的前缀哈希值（1-indexed）
                    // H[i] = H[i-1]×B + S[i-1]
vector<ull> P;      // P[i] = B^i（B 的 i 次方），用于子串哈希计算

// 【函数 1】构建字符串 S 的哈希表（预处理）
// 参数：S - 待处理的字符串
// 功能：计算所有前缀的哈希值，存入 H 数组
// 索引：使用 1-indexed（H[0]=0, P[0]=1）
void build(const string &S){
    int n = S.size();
    H.assign(n+1, 0);  // H[0]=0（空串的哈希值为 0）
    P.assign(n+1, 1);  // P[0]=1（B^0 = 1）
    
    // 递推计算前缀哈希值
    for(int i=1;i<=n;i++){
        // 核心公式：H[i] = H[i-1] × B + S[i-1]
        // 
        // 【关键】S[i-1] 是字符，但在 C++ 中字符本质是整数！
        // 例如：'a' = 97, 'b' = 98, 'c' = 99 (ASCII 码)
        //      'A' = 65, 'B' = 66, '0' = 48, '1' = 49
        // 
        // 当你写 H[i-1]*B + S[i-1] 时：
        //   S[i-1] 会自动转换为它的 ASCII 值（整数）
        //   然后进行数值运算
        // 
        // 完整例子（假设 B=131）：
        //   字符串 "abc"
        //   H[0] = 0
        //   H[1] = 0×131 + 'a' = 0×131 + 97 = 97
        //   H[2] = 97×131 + 'b' = 97×131 + 98 = 12805
        //   H[3] = 12805×131 + 'c' = 12805×131 + 99 = 1677554
        // 
        // 类比十进制：
        //   数字 "123" = 1×10² + 2×10¹ + 3×10⁰
        //   递推：0 → 1 → 12 → 123
        //        0×10+1=1, 1×10+2=12, 12×10+3=123
        H[i] = H[i-1]*B + S[i-1];  // S[i-1] 自动转为 ASCII 值（整数）
                                    // ull 自动 mod 2^64，无需手动取模
        
        // 预计算 B 的幂次，用于后续子串哈希
        P[i] = P[i-1]*B;           // P[i] = B^i
    }
}

// 【函数 2】获取子串 [l, r] 的哈希值
// 参数：l, r - 子串的起止位置（1-indexed，闭区间）
// 返回：子串 S[l-1..r-1]（0-indexed）的哈希值
// 公式：hash(l,r) = H[r] - H[l-1] × B^(r-l+1)
// 原理：类似数字减法
//   例如：123456 - 123×10³ = 456
//        hash("abcdef") - hash("abc")×B³ = hash("def")
ull get(int l, int r){
    // 前缀差法：H[r] 包含 [1,r]，H[l-1] 包含 [1,l-1]
    // 相减得到 [l,r]，但需要对齐位数（乘以 B^(r-l+1)）
    return H[r] - H[l-1]*P[r-l+1];
}

// 【用法示例 1】字符串匹配（类似 KMP，但更简洁）
// 功能：在文本串 S 中查找所有模式串 T 的出现位置
// 时间复杂度：O(n + m)
void example_match(){
    string S, T;  // S=文本串，T=模式串
    cin >> S >> T;
    build(S);     // 预处理文本串的哈希表
    
    // 计算模式串 T 的整体哈希值（不用 build，直接算）
    ull ht = 0;
    for(char c : T) ht = ht*B + c;  // 递推：ht = ht×B + c
    
    // 滑动窗口：枚举 S 中所有长度为 m 的子串
    int n = S.size(), m = T.size();
    for(int i=1;i+m-1<=n;i++){  // i 是起点（1-indexed）
        // 比较子串 S[i..i+m-1] 的哈希值与模式串的哈希值
        if(get(i, i+m-1) == ht){
            cout << i << "\n";  // 输出匹配位置（1-indexed）
        }
    }
}

// 【用法示例 2】字符串去重（统计不同字符串个数）
// 功能：读入 n 个字符串，统计有多少个不同的字符串
// 原理：用 set 存储哈希值，自动去重
// 时间复杂度：O(n × m)，m 为平均字符串长度
void example_dedup(){
    int n;
    cin >> n;
    set<ull> seen;  // 存储已出现的哈希值
    int cnt = 0;    // 不同字符串的计数
    
    for(int i=0;i<n;i++){
        string s;
        cin >> s;
        
        // 计算字符串 s 的哈希值（整串计算，无需 build）
        ull h = 0;
        for(char c : s) h = h*B + c;
        
        // set::insert 返回 pair<iterator, bool>
        // .second 为 true 表示插入成功（之前不存在）
        if(seen.insert(h).second) cnt++;
    }
    cout << cnt << "\n";
}

// 【用法示例 3】最长公共前缀（LCP，Longest Common Prefix）
// 功能：计算字符串 S 的两个后缀 S[i1..] 和 S[i2..] 的最长公共前缀长度
// 参数：i1, i2 - 两个后缀的起点（1-indexed）
//       n - 字符串总长度
// 原理：二分答案 + 哈希比较
// 时间复杂度：O(log n)
int lcp(int i1, int i2, int n){
    // 二分搜索最长公共前缀的长度
    int l = 0;  // 最小长度（最坏情况：无公共前缀）
    int r = n - max(i1, i2) + 1;  // 最大可能长度（受较短后缀限制）
    
    // 二分查找：找最大的 len 使得 S[i1..i1+len-1] == S[i2..i2+len-1]
    while(l < r){
        int mid = (l + r + 1) / 2;  // 上取整，避免死循环
        
        // 比较长度为 mid 的前缀是否相同
        // S[i1..i1+mid-1] 和 S[i2..i2+mid-1]
        if(get(i1, i1+mid-1) == get(i2, i2+mid-1)){
            l = mid;  // 长度 mid 可行，尝试更长
        } else {
            r = mid - 1;  // 长度 mid 不可行，缩小范围
        }
    }
    return l;  // 返回最长公共前缀长度
}

// 【演示】字符 → 数字的转换过程
void demo_char_to_int(){
    cout << "==== 字符就是数字（ASCII 码）====\n";
    cout << "'a' = " << (int)'a' << "\n";  // 97
    cout << "'b' = " << (int)'b' << "\n";  // 98
    cout << "'c' = " << (int)'c' << "\n";  // 99
    cout << "'A' = " << (int)'A' << "\n";  // 65
    cout << "'0' = " << (int)'0' << "\n";  // 48
    
    cout << "\n==== 字符可以直接参与数值运算 ====\n";
    char ch = 'a';
    ull result = 100 + ch;  // 100 + 97 = 197
    cout << "100 + 'a' = 100 + " << (int)ch << " = " << result << "\n";
    
    cout << "\n==== 模拟哈希计算过程（B=131）====\n";
    string s = "abc";
    ull h = 0;
    for(int i = 0; i < s.size(); i++){
        cout << "步骤 " << i+1 << ": ";
        cout << "h = " << h << " × 131 + '" << s[i] << "'(" << (int)s[i] << ")";
        h = h * 131 + s[i];
        cout << " = " << h << "\n";
    }
    cout << "最终 hash(\"abc\") = " << h << "\n";
}

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    
    // 演示字符转数字（取消注释查看）
    // demo_char_to_int();
    
    // 根据题目选择示例
    // example_match();
    
    return 0;
}

/*
 * ==================== 核心知识点 ====================
 * 
 * 【核心公式】
 * 子串哈希：hash(s[l..r]) = H[r] - H[l-1] × B^(r-l+1)
 * 
 * 【原理解释】
 * 把字符串看作 B 进制数：
 *   "abc" = a×B² + b×B¹ + c×B⁰
 * 类比十进制：
 *   "123" = 1×10² + 2×10¹ + 3×10⁰ = 123
 * 
 * 【为什么用 ULL 自然溢出？】
 * 1. 自动 mod 2^64，无需手动取模（CPU 自动处理）
 * 2. 速度快（无取模运算），代码简洁
 * 3. 碰撞概率 ≈ 1/2^64 ≈ 5.4×10^-20（极低）
 * 4. 对于 10^6 个字符串，碰撞概率 ≈ 0.0000001%
 * 
 * 【唯一性问题】
 * ⚠️ 字符串哈希不保证 100% 唯一！
 * - 原因：鸽笼原理（无限字符串 → 有限哈希值）
 * - 实践：碰撞概率极低，竞赛中可当确定性算法用
 * 
 * 【防卡方案（降低碰撞概率）】
 * 普通题（95%）：单哈希 + B=131 即可
 * 重要比赛：
 *   方案 1：随机基数
 *     mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
 *     ull B = (rng() % 1000000) + 256;
 *     if(B % 2 == 0) B++;  // 保证奇数
 * 
 *   方案 2：双哈希（ULL + 单模数）
 *     ull hash1 = ...;         // B=131, mod 2^64
 *     ll hash2 = ... % 1e9+7;  // B=13331, mod 1e9+7
 *     碰撞概率降至 ≈ 10^-29
 * 
 *   方案 3：双模数
 *     同时维护 mod 1e9+7 和 mod 1e9+9
 * 
 * 【基数 B 的选择】
 * - 原则：B > 字符集大小（ASCII=128，所以 B≥131）
 * - 推荐：131（最常用）、13331（更大更稳）
 * - 要求：与模数互素（最好选奇数）
 * - 为什么 131？经验值，实践中分布均匀、碰撞少
 * 
 * 【常见应用场景】
 * 1. 字符串匹配（代替 KMP，代码更简洁）
 * 2. 字符串去重（替代 map/set 存整串）
 * 3. 最长公共子串（LCS）
 * 4. 回文串判断（正串哈希 == 反串哈希）
 * 5. 最长回文子串（中心扩展 + 哈希）
 * 6. 字典序比较（二分 + 哈希找第一个不同位置）
 * 7. 最长公共前缀（LCP，二分 + 哈希）
 * 
 * 【时间复杂度对比】
 * | 操作 | 朴素算法 | KMP | 字符串哈希 |
 * |------|---------|-----|-----------|
 * | 预处理 | - | O(m) | O(n) |
 * | 单次匹配 | O(nm) | O(n+m) | O(n+m) |
 * | 代码量 | 短 | 长 | 很短 |
 * 
 * 【提交前检查清单】
 * - [ ] 索引方式：0-indexed 还是 1-indexed？
 * - [ ] 字符映射：考虑大小写？只有字母？包含特殊字符？
 * - [ ] 是否需要双哈希防卡？（强制在线/对抗性题目）
 * - [ ] 数组大小：H 和 P 是否足够大？
 * - [ ] 边界情况：空串、单字符、完全相同的串
 */
