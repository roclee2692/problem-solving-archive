/*
 * 【AC 自动机（Aho-Corasick Automaton）】
 * 
 * 核心思想：Trie 树 + KMP 的 fail 指针 = 多模式串匹配
 * 
 * 作用：在一个文本串中同时查找多个模式串的出现
 * 时间复杂度：O(∑|P| + |T| + 答案数)
 *   - 构建 Trie：O(∑|P|)，P 是所有模式串
 *   - 构建 fail：O(∑|P|)
 *   - 匹配：O(|T|)，T 是文本串
 * 
 * 空间复杂度：O(∑|P| × ALPHABET_SIZE)
 * 
 * 适用场景：
 *   - 多模式串匹配（敏感词过滤）
 *   - 统计模式串出现次数
 *   - 找所有模式串的出现位置
 * 
 * 模板题：洛谷 P3808 - 【模板】AC 自动机（简单版）
 */

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
using pll = pair<ll,ll>;

/* ==================== 全局变量定义 ==================== */
const int L = 26;           // 字母表大小（a-z）
const int N = 1e6 + 5;      // 节点数上限（所有模式串总长度）

// 【核心数组】
ll nxt[N][L];    // Trie 树：nxt[u][c] = 从节点 u 走字符 c 到达的节点编号
                 // 如果不存在，buildfail 后会指向 fail 树上的对应节点

ll fail[N];      // fail 指针：fail[u] = 节点 u 代表的字符串的最长真后缀对应的节点
                 // 类似 KMP 的 next 数组，用于失配时的跳转
//fail本质是在本条链路和符合条件链路的最长公共前后缀的回退
ll outcnt[N];    // 终止节点标记：outcnt[u] = 有多少个模式串以节点 u 结尾
                 // 支持重复模式串的统计

ll occ[N];  // 命中/ 匹配计数
// occurrence 的缩写，XCPC 标准命名
 // 访问计数：occ[u] = 在文本匹配时到达节点 u 的次数
// 用于统计每个节点被访问的频率

ll tot = 1;      // 当前已分配的节点总数（节点编号从 1 开始）
ll root = 1;     // 根节点编号（固定为 1）

vector<ll> bfsorder;  // BFS 遍历顺序：用于后续逆序统计 fail 链上的贡献

ll n;            // 模式串数量
string t;        // 文本串

/* ==================== 辅助函数 ==================== */

// 【函数 1】字符映射：将字符转换为数组下标
// 功能：把字符 'a'-'z' 映射到 0-25
inline ll idx(char ch) { 
    return ch - 'a'; 
}

/* ==================== AC 自动机构建 ==================== */

// 【函数 2】插入模式串到 Trie 树
// 功能：将字符串 s 插入到 Trie 树中
// 时间复杂度：O(|s|)
inline void insertStr(const string& s) {
    ll u = root;  // 从根节点开始
    
    // 逐字符插入
    for (char ch : s) {
        ll id = idx(ch);  // 获取字符对应的下标
        
        // 如果当前字符的子节点不存在，创建新节点
        if (!nxt[u][id]) {
            nxt[u][id] = ++tot;  // 分配新节点编号
        }
        
        u = nxt[u][id];  // 移动到子节点
        
        // 注意：在建 Trie 阶段，u 严格递增（1 → 2 → 3 → ...）
        // 因为每次都是往下走，不会遇到环
    }
    
    // 标记该节点为某个模式串的结尾
    outcnt[u]++;  // 支持重复模式串：每个相同串都单独计数
                  // 例如：插入 "abc" 两次，outcnt[u] = 2
}

// 【函数 3】构建 fail 指针（核心函数）
// 功能：为 Trie 树的每个节点构建 fail 指针，形成 AC 自动机
// 原理：类似 KMP 算法，fail[u] 指向 u 代表字符串的最长真后缀
// 时间复杂度：O(∑|P|)
inline void buildfail() {
    queue<ll> q;  // BFS 队列
    
    // 【第一步】初始化根节点的所有子节点
    // 处理深度为 1 的节点（根的直接子节点）
    for (ll c = 0; c < L; c++) {
        ll v = nxt[root][c];  // 根节点的第 c 个子节点
        
        if (v) {
            // 【情况 1】如果子节点 v 存在（即有模式串以字符 c 开头）
            fail[v] = root;  // 深度为 1 的节点，fail 指向根
            q.push(v);       // 加入 BFS 队列，后续处理其子节点
            
            // 【为什么 fail[v] = root？】
            // v 代表的字符串只有一个字符（如 "a"）
            // "a" 的最长真后缀是空串，对应根节点
            // 如果在 v 失配，应该回退到根节点重新开始匹配
        } else {
            // 【情况 2】如果子节点不存在（即没有模式串以字符 c 开头）
            nxt[root][c] = root;  // 让 nxt[root][c] 指向根（自环）
            
            // 【为什么这样做？核心原因有两个】
            
            // 原因 1：避免访问空指针
            // 如果不设置，nxt[root][c] = 0（空）
            // 匹配时执行 u = nxt[u][c] 会跳到节点 0（非法）
            
            // 原因 2：统一处理逻辑，消除特判
            // 设置后，匹配代码可以简化为：u = nxt[u][c]
            // 不需要写：if (nxt[u][c]) u = nxt[u][c]; else u = root;
            
            // 【语义解释】
            // 从根读取字符 c 失配时，应该留在根节点
            // 因为根代表"空串状态"，可以接受任何字符重新开始
            // 例如：模式串只有 "ab"，文本读到 'x'
            //       nxt[root]['x'] = root，留在根，继续读下一个字符
            
            // 【与后续路径压缩的关系】
            // 这个自环是有意义的！
            // 后面 buildfail() 中的路径压缩会利用这个性质
            // 保证所有 nxt[u][c] 都是有效节点（不会是 0）
        }
    }
    
    // 【对比：如果不做 nxt[root][c] = root 会怎样？】
    // 假设模式串: "ab", "bc"
    // 文本串: "xabc"
    //
    // 不设置自环的情况:
    //   读 'x': nxt[root]['x'] = 0 (空) → 需要特判: if (v == 0) u = root;
    //   代码变复杂,每次转移都要检查是否为 0
    //
    // 设置自环后:
    //   读 'x': nxt[root]['x'] = root → 直接 u = nxt[u][c], 无需特判
    //   代码简洁: u = nxt[u][c] 一行搞定
    //
    // 结论: 自环让匹配代码更简洁、统一,不需要特殊处理根节点
    
    // 【第二步】BFS 构建其余节点的 fail 指针
    while (!q.empty()) {
        ll u = q.front(); 
        q.pop();
        
        // 记录 BFS 顺序（用于后续逆序统计）
        bfsorder.push_back(u);
        
        // 遍历当前节点的所有可能字符转移
        for (ll c = 0; c < L; c++) {
            ll v = nxt[u][c];  // u 通过字符 c 到达的节点
            
            if (v) {
                // 【情况 1】如果边 u --c--> v 存在
                
                // 计算 fail[v]：
                // fail[u] 是 u 的最长真后缀，nxt[fail[u]][c] 就是加上字符 c 后的最长后缀
                fail[v] = nxt[fail[u]][c];
                
                q.push(v);  // 将 v 加入队列继续 BFS
                
                // 【fail 指针的意义】
                // fail[v] 表示：字符串 str(v) 的最长真后缀对应的节点
                // 例如：str(v) = "abc"，fail[v] 可能指向 "bc" 或 "c"
            } else {
                // 【情况 2】如果边 u --c--> v 不存在
                
                // 【路径压缩优化】直接让 nxt[u][c] 指向 fail 树上的对应节点
                nxt[u][c] = nxt[fail[u]][c];
                
                // 含义：从 u 读字符 c 失配时，不需要 while 循环回退
                // 直接跳到 fail[u] 读 c 应该到达的位置
                
                // 可能出现自环：nxt[u][c] = u
                // 例如：节点 u 代表 "aa"，读到 'a' 后到达 "aaa"
                // 如果 "aaa" 不存在，会跳到 fail[u] = "a"，再读 'a' 得到 "aa"（回到自己）
                // 这是正确的：说明这个前缀已经包含自己，无需回退
            }
        }
    }
    
    // 【总结】
    // 经过 buildfail() 后：
    // 1. fail[u] 构建完成：指向最长真后缀
    // 2. nxt[u][c] 可能被修改：不存在的边指向 fail 树对应位置
    // 3. bfsorder 记录了 BFS 顺序：用于后续统计
}

// 【函数 4】匹配文本串，统计出现的不同模式串数量
// 功能：在文本串 text 中匹配所有模式串，返回出现过的不同模式串的数量
// 时间复杂度：O(|text| + tot)，其中 tot 是 Trie 节点总数
inline ll matchCountDistinct(const string& text) {
    ll u = root;  // 从根节点开始匹配
    
    // 【第一阶段】扫描文本串，标记所有直接到达的节点
    // 类比：坐地铁，每到一站就"打卡"
    for (char ch : text) {
        // 【关键转移】利用路径压缩后的 nxt 数组，一步到位
        u = nxt[u][idx(ch)];
        // 比喻：坐 "ch 号地铁"，从当前站 u 直达下一站
        // 不需要 while 回退！buildfail() 已经把不存在的边指向了正确位置
        
        // 标记：到达节点 u
        occ[u] += 1;
        // 比喻：在这个站点"打卡：来过一次"
    }
    // 【此时 occ[u] 的含义】
    // occ[u] 表示在匹配过程中，直接到达节点 u 的次数
    // 例如：text = "ababc"，模式串 "ab" 对应节点 v
    //       如果 text 中 "ab" 出现 2 次，则 occ[v] = 2
    
    // 【第二阶段】逆 BFS 序沿 fail 链汇总贡献
    // 原理：如果匹配到更长的后缀，那么所有短后缀也一定匹配
    // 例如：匹配到 "abc"，那么 "bc" 和 "c" 也一定匹配
    for (int i = (int)bfsorder.size() - 1; i >= 0; --i) {
        int x = bfsorder[i];
        
        // 【fail 链传递】
        // 将节点 x 的出现次数累加到其 fail 父节点
        occ[fail[x]] += occ[x];
//本质是 匹配失败的才会回退 但是正确匹配的次数没有计入 所以要将当前x分支正确匹配的次数累加到前缀fail[x]分支
        
        // 【为什么这样做？深度解析】
        // 
        // 问题根源：
        // 在第一阶段扫描文本串时，我们只统计了"直接完全匹配"的节点
        // 例如：文本串 "she" 完全匹配了模式串 "she"，节点 x (代表 "she") 执行了 occ[x]++
        // 
        // 但实际上，"she" 包含后缀 "he" 和 "e"
        // 虽然 "he" 和 "e" 在文本中也出现了（作为 "she" 的后缀）
        // 但在匹配过程中，因为一直匹配成功（s → sh → she），没有失配
        // 所以没有走 fail 指针回退到 "he" 或 "e" 对应的节点
        // 导致这些后缀节点的 occ 值为 0，统计遗漏了！
        // 
        // 换句话说：
        // - 匹配成功的路径：我们直接走 nxt 边，统计了完整串（如 "she"）
        // - 匹配失败的路径：会走 fail 边回退，统计了失配后的短串
        // - 问题：成功匹配时，那些"被包含的短后缀"没有被统计到！
        // 
        // 解决方案：
        // fail[x] 指向 x 的最长真后缀
        // 如果 str(x) 完全匹配了，那么 str(fail[x]) 作为后缀也一定出现
        // 我们需要把 x 的出现次数"传递"给 fail[x]，补上这个遗漏的计数
        // 本质就是：把"成功匹配时被跳过的后缀节点"的计数补上
        // 
        // 具体例子：
        // 模式串: "she", "he", "her"
        // 文本串: "she"
        // 
        // 第一阶段扫描后:
        //   occ[节点"she"] = 1  ✓ 直接到达
        //   occ[节点"he"]  = 0  ✗ 没有显式经过，但逻辑上应该是 1
        //   occ[节点"e"]   = 0  ✗ 没有显式经过，但逻辑上应该是 1
        // 
        // 第二阶段 fail 链传递:
        //   处理节点 x="she": occ[fail[x]] += occ[x]
        //                    即 occ["he"] += 1  → occ["he"] = 1 ✓
        //   处理节点 y="he":  occ[fail[y]] += occ[y]
        //                    即 occ["e"] += 1   → occ["e"] = 1  ✓
        // 
        // 最终所有后缀的计数都正确了！
        // 
        // 本质：
        // 这不是"统计失败后的回退"，而是"后缀必然出现的逻辑传递"
        // 长串的出现，必然导致其所有后缀（fail 链上的祖先）也出现
        // 通过 fail 链传递，我们把这个隐式的"包含关系"显式地统计出来
        
        // 【为什么逆序？关键中的关键】
        // bfsorder 是 BFS 顺序（深度递增）：根 → 浅 → 深
        // 例如：[root, "e", "he", "she"]
        // 
        // 必须逆序遍历的原因：
        // fail 链是从深到浅的：子节点 → 父节点
        // 例如：fail["she"] = "he", fail["he"] = "e"
        // 
        // 如果正序遍历（错误示范）：
        //   先处理 "e":  occ[fail["e"]] += occ["e"]  (occ["e"]=0，什么都没传)
        //   再处理 "he": occ[fail["he"]] += occ["he"] (occ["he"]=0，什么都没传)
        //   最后 "she": occ[fail["she"]] += occ["she"] (occ["she"]=1，传给"he")
        //   结果：occ["he"]=1, occ["e"]=0  ✗ "e" 的计数丢失了！
        // 
        // 如果逆序遍历（正确做法）：
        //   先处理 "she": occ["he"] += occ["she"]=1  → occ["he"]=1
        //   再处理 "he":  occ["e"]  += occ["he"]=1   → occ["e"]=1
        //   最后 "e":    occ[root] += occ["e"]=1
        //   结果：所有节点的计数都正确！✓
        // 
        // 总结：
        // 逆序确保"深层节点的贡献先传递给浅层父节点"
        // 然后"浅层父节点再继续向上传递"
        // 这样才能保证 fail 链上所有祖先都收到完整的贡献
    }
    
    // 【第三阶段】统计答案
    // 统计所有被匹配到且是模式串结尾的节点
    long long ans = 0;
    for (int u2 = 1; u2 <= tot; ++u2) {
        // 如果节点 u2 被访问过 且 是某个模式串的结尾
        if (occ[u2] > 0 && outcnt[u2] > 0) {
        // "occ 确定循环运行中哪些字符（节点）在文本串中出现过"
        // "outcnt 是我们模式串完整的结尾"
        // "都满足才能唯一确定该模式串在文本中实际出现的次数"
            // 累加该节点代表的模式串数量
            ans += outcnt[u2];
            
            // 【outcnt[u2] 的含义】
            // outcnt[u2] 表示以节点 u2 结尾的不同模式串数量
            // 如果同一个模式串插入多次，outcnt[u2] > 1
            // 例如：插入 "ab" 两次，对应节点 v 的 outcnt[v] = 2
        }
    }
    
    return ans;
    
    // 【返回值含义】
    // ans 表示在 text 中出现过的不同模式串的总数量
    // 注意：如果同一个模式串插入多次，会计数多次
    
    // 【复杂度分析】
    // 第一阶段：O(|text|) - 扫描文本串
    // 第二阶段：O(tot) - 遍历所有 Trie 节点
    // 第三阶段：O(tot) - 统计答案
    // 总复杂度：O(|text| + tot)
}

// 【主函数】AC 自动机使用示例
int main() {
    // 快速 I/O 优化
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 【步骤 1】读入模式串数量
    cin >> n;
    
    // 【步骤 2】构建 Trie 树
    // 将所有模式串插入到 Trie 中
    string s;
    for (int i = 1; i <= n; ++i) {
        cin >> s;         // 读入第 i 个模式串
        insertStr(s);     // 插入到 Trie 树中
    }
    // 此时 Trie 树已构建完成，包含所有模式串
    
    // 【步骤 3】读入文本串
    cin >> t;
    
    // 【步骤 4】构建 fail 指针
    buildfail();
    // 此时 AC 自动机已完全构建完成
    // Trie 树 + fail 指针 = AC 自动机
    
    // 【步骤 5】匹配并输出结果
    cout << matchCountDistinct(t) << "\n";
    // 输出在文本串 t 中出现的不同模式串数量
    
    return 0;
}

/*
╔═══════════════════════════════════════════════════════════════════════════╗
║                          AC 自动机知识总结                                    ║
╚═══════════════════════════════════════════════════════════════════════════╝

【一、核心思想】
AC 自动机 = Trie 树 + KMP 的 fail 指针
- Trie 树：存储所有模式串，支持多模式串匹配
- fail 指针：类似 KMP 的 next 数组，指向最长真后缀，实现高效匹配

【二、三大核心数组】
1. nxt[u][c]：Trie 树的边，从节点 u 通过字符 c 到达的节点
   - 经过 buildfail() 后会被修改（路径压缩）
   - 不存在的边会指向 fail 树上的对应位置

2. fail[u]：fail 指针，指向 u 代表字符串的最长真后缀对应的节点
   - 类似 KMP 的 next 数组
   - fail[u] 的深度 < u 的深度（根的深度为 0）

3. outcnt[u]：节点 u 作为结尾的模式串数量
   - 如果同一模式串插入多次，outcnt[u] > 1
   - 用于统计答案

【三、算法流程】
1. insertStr(s)：将模式串 s 插入 Trie 树
2. buildfail()：BFS 构建 fail 指针，形成 AC 自动机
3. matchCountDistinct(text)：在文本串中匹配所有模式串

【四、时间复杂度】
- 构建 Trie：O(∑|P|)，其中 ∑|P| 是所有模式串长度之和
- 构建 fail：O(∑|P|)
- 匹配文本：O(|T| + tot)，其中 |T| 是文本串长度，tot 是 Trie 节点数
- 总复杂度：O(∑|P| + |T|)

【五、与其他算法的对比】
┌─────────────┬─────────────┬─────────────┬─────────────┐
│   算法      │  适用场景    │  时间复杂度  │   空间复杂度 │
├─────────────┼─────────────┼─────────────┼─────────────┤
│   KMP       │ 单模式串匹配 │ O(n + m)    │ O(m)        │
│   Trie      │ 多串前缀查询 │ O(∑|P|)     │ O(∑|P| × Σ) │
│ AC 自动机   │ 多模式串匹配 │ O(∑|P| + n) │ O(∑|P| × Σ) │
└─────────────┴─────────────┴─────────────┴─────────────┘

【六、关键技巧】
1. 路径压缩：nxt[u][c] = nxt[fail[u]][c]
   - 避免匹配时 while 回退
   - 可能产生自环（正确的）

2. fail 链传递：occ[fail[u]] += occ[u]
   - 逆 BFS 序遍历
   - 确保子节点先处理

3. BFS 构建 fail：
   - 深度为 1 的节点 fail 指向根
   - 其他节点：fail[v] = nxt[fail[u]][c]

【七、常见变体】
1. 统计每个模式串的出现次数
   - 需要记录每个模式串的编号
   - 在 insertStr() 中为每个串分配 ID

2. 统计所有模式串出现次数之和
   - 在匹配时遍历 fail 链
   - 累加所有 fail 祖先的 outcnt

3. 找出所有匹配位置
   - 在匹配时记录当前位置
   - 遍历 fail 链输出所有匹配

【八、常见错误】
1. ❌ 忘记调用 buildfail()
   - 只有 Trie 没有 fail 指针，无法正确匹配

2. ❌ fail 链传递不逆序
   - 会导致统计错误，因为子节点还没处理完

3. ❌ 路径压缩理解错误
   - nxt[u][c] 可能指向自己（自环），这是正确的

4. ❌ 混淆 0-indexed 和 1-indexed
   - 本实现：根节点编号为 1（1-indexed）
   - 字符映射：'a' -> 0（0-indexed）

【九、优化技巧】
1. 字符集大小 L 的选择
   - 小写字母：L = 26
   - 大小写字母：L = 52
   - 可见 ASCII：L = 95

2. 空间优化
   - 使用 map<int, int> 代替固定数组（稀疏图）
   - 使用 vector 动态分配节点

3. 时间优化
   - 路径压缩（已实现）
   - 跳过 fail 链中 outcnt = 0 的节点

【十、典型题目】
- 洛谷 P3808：AC 自动机模板
- 洛谷 P3796：AC 自动机（简单版）
- POJ 2778：DNA Sequence（AC 自动机 + 矩阵快速幂）
- HDU 2222：Keywords Search（AC 自动机经典题）

*/