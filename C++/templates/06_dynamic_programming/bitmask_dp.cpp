/*
 * 【位运算 DP】- 状态压缩动态规划
 * ════════════════════════════════════════════════════════════════════════════
 * 
 * 【核心思想】
 * 用一个整数的二进制位表示集合状态，每一位代表集合中是否包含某个元素。
 * 这样可以用常数时间进行集合的添加/删除操作，节省存储和计算空间。
 * 
 * 【时间复杂度】
 *   - 状态数：2^n（每个状态对应 0～2^n-1 之间的一个整数）
 *   - 状态转移：取决于具体问题
 *   - 一般情况：O(n * 2^n * m) 或 O(3^n)
 * 
 * 【空间复杂度】
 *   - O(2^n)：需要存储 2^n 个状态的答案
 * 
 * 【限制条件】
 *   - n ≤ 20（或稍大，取决于内存和时间限制）
 *   - 原因：int 有 32 位，2^20 ≈ 100 万可以接受；2^30 ≈ 10 亿太大了
 *   - 超过这个范围需要用其他方法（如 meet-in-the-middle、启发式搜索等）
 * 
 * 【适用场景】
 *   - 旅行商问题（TSP）：dp[mask][i] = 访问过 mask 中的所有城市且在城市 i 的最小成本
 *   - 棋盘覆盖问题：用位表示棋盘的每一行状态
 *   - 子集枚举问题：计算所有子集的某个性质
 *   - 图上的路径计数：访问某些顶点的所有可能路径
 *   - 集合划分问题：按位分组
 * 
 * 【经典模板题】
 *   - 洛谷 P1097 - 统计数字
 *   - Codeforces 10D - LCIS（最长递增子序列）
 *   - AtCoder DP 篇 - 组合计数问题
 * 
 * ════════════════════════════════════════════════════════════════════════════
 */

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

// ════════════════════════════════════════════════════════════════════════════
// 【位运算 DP 模板】
// ════════════════════════════════════════════════════════════════════════════
// 说明：`namespace` 是命名空间，用于组织函数/变量/类型并避免命名冲突。
// 它不是类型，不能被实例化或继承；通过 `BitDP::symbol` 访问命名空间内的符号。
// 命名空间可以在多处重开（reopen），同名内容会合并。
// 示例（别名与调用）：
//   namespace B = BitDP; // 别名
//   B::solve();           // 通过作用域运算符调用命名空间内的函数
namespace BitDP {
    int n, m;
    vector<ll> dp;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 【方法 1】前向转移：从小集合扩展到大集合
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 适用场景：计数问题、路径问题、寻找所有可达状态
    // 时间复杂度：O(n * 2^n)
    void solve1() {
        cin >> n >> m;
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【核心思想】状态压缩 DP：用一个整数的二进制位表示集合状态
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 为什么要压缩状态？
        //   - 如果用集合表示状态（如 set<int>），存储和比较都很慢
        //   - 用一个整数的每一位代表集合中的一个元素
        //   - 第 i 位为 1 表示元素 i 在集合中，为 0 表示不在
        //   - 例如 n=3 时，mask=5 (二进制 101) 表示集合 {0, 2}
        //
        // 为什么只能用于 n ≤ 20？
        //   - int 有 32 位，能表示 2^32 个状态
        //   - 当 n=20 时，需要遍历 2^20 = 约 100 万个状态，可以接受
        //   - 当 n=25 时，需要 2^25 = 约 3300 万个状态，内存和时间都不够
        //   - 对于更大的 n，需要用其他方法（如 meet-in-the-middle）
        
        // dp[mask] 表示状态 mask 下的答案
        // 分配 2^n 个状态空间（从 0 到 2^n - 1）
        dp.assign(1 << n, 0);  // (1 << n) 等价于 2^n
        dp[0] = 1;  // 初值：空集（没有选任何元素）的答案是 1
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【方式 1】从前向后扩展状态（向 mask 中添加元素）
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 执行流程演示（以 n=3 为例）：
        //
        // 初始：dp = [1, 0, 0, 0, 0, 0, 0, 0]
        //       mask 值：0   1   2   3   4   5   6   7
        //       含义：  ∅  {0} {1} {0,1} {2} {0,2} {1,2} {0,1,2}
        //
        // 第 1 轮（mask=0，二进制 000，表示空集）：
        //   ├─ i=0: 检查 (000 & 001)=0 ✓ 可加 → new_mask=001(1) → dp[1]+=dp[0]=1
        //   ├─ i=1: 检查 (000 & 010)=0 ✓ 可加 → new_mask=010(2) → dp[2]+=dp[0]=1
        //   └─ i=2: 检查 (000 & 100)=0 ✓ 可加 → new_mask=100(4) → dp[4]+=dp[0]=1
        //   结果：dp = [1, 1, 1, 0, 1, 0, 0, 0]
        //
        // 第 2 轮（mask=1，二进制 001，表示 {0}）：
        //   ├─ i=0: 检查 (001 & 001)=1 ✗ 不能加（0 已选）
        //   ├─ i=1: 检查 (001 & 010)=0 ✓ 可加 → new_mask=011(3) → dp[3]+=dp[1]=1
        //   └─ i=2: 检查 (001 & 100)=0 ✓ 可加 → new_mask=101(5) → dp[5]+=dp[1]=1
        //   结果：dp = [1, 1, 1, 1, 1, 1, 0, 0]
        //
        // 第 3 轮（mask=2，二进制 010，表示 {1}）：
        //   ├─ i=0: 检查 (010 & 001)=0 ✓ 可加 → new_mask=011(3) → dp[3]+=dp[2]=2 ← 重点！
        //   ├─ i=1: 检查 (010 & 010)=2 ✗ 不能加（1 已选）
        //   └─ i=2: 检查 (010 & 100)=0 ✓ 可加 → new_mask=110(6) → dp[6]+=dp[2]=1
        //   结果：dp = [1, 1, 1, 2, 1, 1, 1, 0]  ← dp[3] 从 1 变成 2
        //
        // ... 继续下去 ...
        //
        // 最终：dp = [1, 1, 1, 2, 1, 2, 2, 6]
        //   dp[3]=2 表示：到达状态 {0,1} 有 2 条路径（从 {0}→{0,1} 或 {1}→{0,1}）
        //   dp[7]=6 表示：到达状态 {0,1,2} 有 6 条路径（所有可能的顺序组合）
        
        for (int mask = 0; mask < (1 << n); mask++) {
            if (dp[mask] == 0) continue;  // 优化：跳过未到达的状态
            
            // 尝试向 mask 中添加第 i 个元素，转移到新状态 new_mask
            // 这种方式避免了重复计算和冗余比较
            for (int i = 0; i < n; i++) {
                // (mask & (1 << i)) 检查第 i 位是否为 1
                // 如果为 0，说明元素 i 不在 mask 中，可以添加
                if ((mask & (1 << i)) == 0) {  // i 未被选中
                    // (mask | (1 << i)) 将第 i 位置为 1
                    // 即在集合 mask 中加入元素 i
                    int new_mask = mask | (1 << i);
                    
                    // 状态转移：从 mask 转移到 new_mask
                    // dp[new_mask] 累加 dp[mask] 的贡献
                    // 这里假设问题是求路径数（如果是求最小值，改为 min；求最大值改为 max）
                    dp[new_mask] += dp[mask];
                }
            }
        }
    }
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 【方法 2】子集枚举：遍历 mask 的所有子集（不包含空集）
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 适用场景：需要考虑所有子集对的问题（集合划分、背包合并）
    // 时间复杂度：O(3^n)
    void solve2() {
        cin >> n >> m;
        dp.assign(1 << n, 0);
        dp[0] = 1;
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【方式 2】枚举 mask 的所有子集（遍历 mask 包含的所有元素子集）
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 这种方式用于需要考虑所有子集对的问题
        // 总时间复杂度是 O(3^n)，因为所有 mask 的子集数总和 = 3^n
        //
        // 为什么子集枚举是 O(3^n)？
        //   - 空集只有 1 个子集（自己）
        //   - 单元素集 {a} 有 2 个子集（空集、{a}）
        //   - 双元素集 {a,b} 有 4 个子集（空、{a}、{b}、{a,b}）
        //   - n 元素集有 2^n 个子集
        //   - 所有集合的子集总数 = C(n,0)*2^0 + C(n,1)*2^1 + ... + C(n,n)*2^n = 3^n
           
        // 执行流程演示（以 n=3 为例）：
        //
        // 初始：dp = [1, 0, 0, 0, 0, 0, 0, 0]
        //       mask 值：0   1   2   3   4   5   6   7
        //       含义：  ∅  {0} {1} {0,1} {2} {0,2} {1,2} {0,1,2}
        //
        // 第 1 轮（mask=0，二进制 000，表示空集）：
        //   ├─ i=0: 检查 (000 & 001)=0 ✓ 可加 → new_mask=001(1) → dp[1]+=dp[0]=1
        //   ├─ i=1: 检查 (000 & 010)=0 ✓ 可加 → new_mask=010(2) → dp[2]+=dp[0]=1
        //   └─ i=2: 检查 (000 & 100)=0 ✓ 可加 → new_mask=100(4) → dp[4]+=dp[0]=1
        //   结果：dp = [1, 1, 1, 0, 1, 0, 0, 0]
        //
        // 第 2 轮（mask=1，二进制 001，表示 {0}）：
        //   ├─ i=0: 检查 (001 & 001)=1 ✗ 不能加（0 已选）
        //   ├─ i=1: 检查 (001 & 010)=0 ✓ 可加 → new_mask=011(3) → dp[3]+=dp[1]=1
        //   └─ i=2: 检查 (001 & 100)=0 ✓ 可加 → new_mask=101(5) → dp[5]+=dp[1]=1
        //   结果：dp = [1, 1, 1, 1, 1, 1, 0, 0]
        //
        // 第 3 轮（mask=2，二进制 010，表示 {1}）：
        //   ├─ i=0: 检查 (010 & 001)=0 ✓ 可加 → new_mask=011(3) → dp[3]+=dp[2]=2 ← 重点！
        //   ├─ i=1: 检查 (010 & 010)=2 ✗ 不能加（1 已选）
        //   └─ i=2: 检查 (010 & 100)=0 ✓ 可加 → new_mask=110(6) → dp[6]+=dp[2]=1
        //   结果：dp = [1, 1, 1, 2, 1, 1, 1, 0]  ← dp[3] 从 1 变成 2
        //
        // 最终：dp = [1, 1, 1, 2, 1, 2, 2, 6]
        //   dp[3]=2 表示：到达状态 {0,1} 有 2 条路径（从 {0}→{0,1} 或 {1}→{0,1}）
        //   dp[7]=6 表示：到达状态 {0,1,2} 有 6 条路径（所有可能的顺序组合）
        for (int mask = 1; mask < (1 << n); mask++) {
            // 子集枚举的黑魔法：(sub - 1) & mask
            // 这行代码从当前子集直接跳到下一个更小的子集（在 mask 的约束下）
            // 原理：
            //   - sub - 1 会使最低的 1 位变为 0，并向低位进位
            //   - & mask 保证结果只保留 mask 中有 1 的位置
            //   - 因此自动生成下一个更小的子集
            // 例：mask=1101 (13), 子集遍历：1101→1100→1001→1000→0101→0100→0001→0000
            for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {
                // 通用形式：将 mask 分成 sub 和 mask^sub 两部分   a ^ b 当对应位相同为 0，不同为 1
                //从两部分各自的最优方案合并成 mask 的方案
                dp[mask] = max(dp[mask], dp[sub] + dp[mask ^ sub]);
                
                // 或者：累加满足条件的子集贡献
                // if (check(sub)) dp[mask] += dp[sub];
            }
        }
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【位操作工具集】- 状态压缩 DP 常用操作 工具集更多是教学用途，展示有哪些常用操作
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Lambda 表达式：定义匿名函数，这里用于快速查询/修改位状态
        
        // 1. 计算集合大小（有多少个元素被选中）
        //    原理：__builtin_popcount 是 GCC 内置函数，直接硬件计数
        auto popcount = [](int x) { 
            return __builtin_popcount(x);  // 返回 x 的二进制表示中 1 的个数
        };
        // 例：popcount(5) = popcount(101) = 2
        
        // 2. 检查第 k 位是否为 1（元素 k 是否在集合中）
        //    原理：(x >> k) 右移 k 位，& 1 取最低位
        auto count_bit = [](int x, int k) { 
            return (x >> k) & 1;  // 返回第 k 位（0 或 1）
        };
        
        // 3. 设置第 k 位为 1（添加元素 k）
        auto set_bit = [](int x, int k) { 
            return x | (1 << k);
        };
        
        // 4. 清除第 k 位（移除元素 k）
        auto unset_bit = [](int x, int k) { 
            return x & ~(1 << k);
        };
        
        // 5. 翻转第 k 位
        auto toggle = [](int x, int k) { 
            return x ^ (1 << k);
        };
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 根据实际问题选择方法
    BitDP::solve1();  // 前向转移
    // BitDP::solve2();  // 子集枚举
    
    return 0;
}

/*
 * ════════════════════════════════════════════════════════════════════════════
 * 【关键点深入】
 * ════════════════════════════════════════════════════════════════════════════
 * 
 * 1. 【为什么要压缩状态】
 *    - 集合表示：用 set<vector<int>> 存储所有访问过的状态效率很低
 *    - 整数编码：整数的二进制位天然可以表示集合，比较和存储都很快
 *    - 时间效率：位运算只需 1 个 CPU 周期，比条件判断快
 * 
 * 2. 【状态转移的两种常见方式】
 *    a) 前向转移（超集方向）：从较小的集合扩展到较大的集合
 *       for (int mask = 0; mask < (1 << n); mask++)
 *           for (int i = 0; i < n; i++)
 *               if ((mask & (1 << i)) == 0)  // i 不在 mask 中
 *                   dp[mask | (1 << i)] += dp[mask];
 *       优点：避免重复计算，逻辑清晰
 *       用途：计数、寻找所有可达状态
 *    
 *    b) 后向转移（子集方向）：处理当前状态时考虑所有子集
 *       for (int mask = 1; mask < (1 << n); mask++)
 *           for (int sub = mask; sub > 0; sub = (sub - 1) & mask)
 *               dp[mask] = f(dp[mask], dp[sub]);  // 考虑 sub 对 mask 的贡献
 *       优点：子集枚举的技巧性，O(3^n) 处理所有子集对
 *       用途：需要考虑所有子集情况的问题（如集合划分）
 * 
 * 3. 【为什么子集枚举是 O(3^n)】
 *    - 设 S(n) = n 元集合的子集总数 = 2^n
 *    - 遍历所有 mask 的子集：sum of S(k) where k is subset size
 *    - 总复杂度 = C(n,0)*2^0 + C(n,1)*2^1 + ... + C(n,n)*2^n = (1+2)^n = 3^n
 *    - 这是为什么这个方法虽然看起来是 O(2^n * 2^n)，但实际是 O(3^n) 的原因
 * 
 * 4. 【子集枚举的黑魔法】
 *    for (int sub = mask; sub > 0; sub = (sub - 1) & mask)
 *    - sub = mask：第一个子集就是它自己
 *    - sub = (sub - 1) & mask：生成下一个更小的子集
 *      例如 mask = 1101 (13 in decimal):
 *      sub: 1101 -> 1100 -> 1001 -> 1000 -> 0101 -> 0100 -> 0001 -> 0000(退出)
 *    - 实际上这会跳过一些数字（如 1011, 1010 等），只保留 mask 的子集
 * 
 * 5. 【常见位运算操作】
 *    x | (1 << k)：将第 k 位置为 1（添加元素）
 *    x & ~(1 << k)：将第 k 位置为 0（删除元素）
 *    x ^ (1 << k)：翻转第 k 位（切换元素）
 *    x & (x - 1)：消除最低位的 1（常用）
 *    __builtin_popcount(x)：计算 1 的个数（内置函数，很快）
 * 
 * ════════════════════════════════════════════════════════════════════════════
 * 【常见变体实现】
 * ════════════════════════════════════════════════════════════════════════════
 * 
 * 1. 【旅行商问题 (TSP)】
 *    // dp[mask][i] = 访问过 mask 中的城市，且最后在城市 i 的最小成本
 *    dp[1 << 0][0] = 0;  // 从城市 0 开始
 *    for (int mask = 0; mask < (1 << n); mask++) {
 *        for (int u = 0; u < n; u++) {
 *            if ((mask & (1 << u)) == 0 || dp[mask][u] == INF) continue;
 *            for (int v = 0; v < n; v++) {
 *                if (mask & (1 << v)) continue;  // v 已访问
 *                int new_mask = mask | (1 << v);
 *                dp[new_mask][v] = min(dp[new_mask][v], dp[mask][u] + cost[u][v]);
 *            }
 *        }
 *    }
 * 
 * 2. 【棋盘覆盖 (Profile DP)】
 *    // 用一行的状态（1 表示已覆盖，0 表示未覆盖）转移到下一行
 *    // dp[row][mask] = 覆盖到第 row 行，该行状态为 mask 的方案数
 * 
 * 3. 【集合划分计数】
 *    // dp[mask] = 将 mask 中的元素分成若干组的方案数
 *    // 先计算不含全集的子集计数，然后递推
 * 
 * ════════════════════════════════════════════════════════════════════════════
 * 【提交前检查清单】
 * ════════════════════════════════════════════════════════════════════════════
 * ✓ 确认 n ≤ 20（或计算容量后确认 2^n 在内存限制内）
 * ✓ 状态定义明确：dp[mask] 或 dp[mask][extra_dim] 表示什么
 * ✓ 初始状态正确：dp[0] 或 dp[1] 设置无误
 * ✓ 子集枚举公式正确：(sub - 1) & mask 或前向转移 mask | (1 << i)
 * ✓ 状态转移逻辑正确：是求最小/最大/计数还是其他
 * ✓ 输出正确的状态：通常是 dp[(1 << n) - 1] 或某个特定状态\n * ✓ 边界处理：避免访问未定义状态，检查 INF 和 0 的含义\n * ✓ 时间复杂度分析：确认不会 TLE（通常 10^8 操作/秒）\n */
