/*
 * 【树形 DP】- 树上的动态规划
 * 题目里有“不允许同时选相邻节点”的约束（这是典型的树上最大权独立集/“没有上司的舞会”问题）
 * 时间复杂度：O(n) 通常
 * 空间复杂度：O(n)
 * 
 * 适用场景：
 *   - 树上路径问题
 *   - 树的计数问题
 *   - 树的匹配问题
 *   - 树的着色问题
 * 
 * 模板题：
 *   - 洛谷 P1352 - 没有上司的舞会
 *   - Codeforces 1106D - Lunar New Year and a Recursive Sequence
 */

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 5;

vector<int> adj[MAXN];
ll dp[MAXN][2];  // dp[u][0/1] 表示 u 不选/选择时的答案
ll value[MAXN];
int n;

void dfs(int u, int p) {
    dp[u][0] = 0;  // u 不选
    dp[u][1] = value[u];  // u 选
    
    for (int v : adj[u]) {
        if (v == p) continue;
        
        dfs(v, u);
        
        // 如果 u 不选，v 可选可不选
        dp[u][0] += max(dp[v][0], dp[v][1]);
        
        // 如果 u 选，v 不能选
        dp[u][1] += dp[v][0];
    }
}

/*
 * 详细注释与示例（插在 dfs 与 main 之间，教学用途）
 * -----------------------------------------------------------------
 * 为什么这样定义状态？
 *  - 我们需要回答：在以 u 为根的子树中，取哪些节点可以得到最大权值和？
 *  - 将状态拆成两类：u 不被选（dp[u][0]）和 u 被选（dp[u][1]）。
 *  - 这样可以明确子树合并时的约束：若 u 被选，则其直接子节点都不能被选；若 u 不被选，子节点可以自由选择最大值。
 *
 * 为什么初始化为 dp[u][0]=0, dp[u][1]=value[u]？
 *  - dp[u][0] 代表不选 u 的初始贡献为 0，随后累加每个子树能带来的最大贡献。
 *  - dp[u][1] 代表选 u 的初始贡献为自身权值 value[u]，随后只能累加那些在子树中不选子节点时的贡献（dp[v][0]）。
 *
 * 转移推导（对任意子节点 v）
 *  - 若 u 不选：子节点可选可不选 → 贡献为 max(dp[v][0], dp[v][1])
 *  - 若 u 选：子节点不能被选 → 贡献为 dp[v][0]
 *
 * 正当性（直观证明）
 *  - 子问题无重叠且可拆分：一棵树拆成若干子树，根的选与不选将独立决定子树的可选集合。
 *  - 动态规划通过后序遍历保证先算子树再合并，满足最优子结构。
 *
 * 复杂度
 *  - 时间：O(n)，每条边被访问常数次（dfs 遍历一次），每个节点合并其所有子贡献。
 *  - 空间：O(n)（邻接表 + dp），递归栈最坏 O(n)。
 *
 * 具体示例（便于手动检验）
 *  假设树：
 *      1(5)
 *     /   \
 *   2(3)  3(4)
 *  节点格式：id(value)
 *
 *  计算步骤（后序）：
 *   - dfs(2): 没有子节点 → dp[2][0]=0, dp[2][1]=3
 *   - dfs(3): 没有子节点 → dp[3][0]=0, dp[3][1]=4
 *   - 回到 1:
 *       dp[1][0] = max(dp[2][0],dp[2][1]) + max(dp[3][0],dp[3][1]) = 3 + 4 = 7
 *       dp[1][1] = value[1] + dp[2][0] + dp[3][0] = 5 + 0 + 0 = 5
 *   - 答案 = max(dp[1][0], dp[1][1]) = 7 （选择节点 2 和 3）
 *
 * 回溯重构选集（若需要输出具体被选节点）
 *  - 常见做法：在 dfs 中额外维护 choice[u][0/1] 或在完成 dp 后从根开始向下做选择：
 *      1) 比较根的 dp 值决定根是否被选；
 *      2) 若根被选，则对子节点只能沿着 dp[v][0] 方向继续（即不选子节点）；
 *      3) 若根不被选，则对子节点比较 dp[v][0] 与 dp[v][1]，按较大者决定是否选 v，然后递归处理。
 *  - 该回溯过程也是 O(n)。
 *
 * 注意事项
 *  - 若存在负权节点且允许不选任何节点，dp[0] 初值仍为 0；若必须选至少一个节点，需调整初值与合并逻辑。
 *  - 对于大树（n≈1e5），在极端链状树上递归深度可能触及栈限制，必要时改写为非递归 DFS 或增加栈大小。
 */


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    cin >> n;
    
    for (int i = 1; i <= n; i++) {
        cin >> value[i];
    }
    
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    dfs(1, -1);
    
    cout << max(dp[1][0], dp[1][1]) << "\n";
    
    return 0;
}

/*
 * 【关键点】
 * 1. dp[u][0/1]：u 不选/选时的最优值
 * 2. dfs 遍历：从任意根出发（这里从 1）
 * 3. 转移关键：当前节点的选择影响子节点的选择
 * 4. 亲子关系：通过参数 p 避免往父亲方向回溯
 * 5. 合并子树：逐个加入子树的贡献
 * 
 * 【常见变体】
 * - 树上路径：dp[u][d] = 经过 u 且向下距离为 d 的最长路径
 * - 树的匹配：dp[u] = u 的子树中的最大匹配
 * - 树的着色：dp[u][c] = u 着色为 c 时的方案数
 * 
 * 【提交前检查】
 * ✓ 状态定义是否清晰
 * ✓ dfs 遍历是否覆盖所有节点
 * ✓ 转移是否考虑所有情况
 * ✓ 亲子关系处理（避免重复访问）
 */
