/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *                          ç«èµ›å¸¸è€ƒDPç±»å‹æ€»ç»“
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * é€‚ç”¨æ¯”èµ›ï¼šXCPCã€è“æ¡¥æ¯ã€CSPã€Codeforcesã€AtCoder
 * 
 * è€ƒé¢‘æ’åºï¼š
 *   ğŸ”¥ğŸ”¥ğŸ”¥ èƒŒåŒ…DPã€LIS/LCSã€åŒºé—´DP (å¿…ä¼š)
 *   ğŸ”¥ğŸ”¥   çŠ¶æ€å‹ç¼©DPã€æ ‘å½¢DPã€æ•°ä½DP (é«˜é¢‘)
 *   ğŸ”¥     å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–ã€æ–œç‡ä¼˜åŒ–ã€è®¡æ•°DP (è¿›é˜¶)
 */

#include <bits/stdc++.h>
using namespace std;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. çº¿æ€§DP - æŒ‰ä½ç½®é¡ºåºæ¨è¿›
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 1.1 æœ€é•¿ä¸Šå‡å­åºåˆ— (LIS) - O(nÂ²) / O(n log n)                           â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ è“æ¡¥æ¯â­â­â­â­â­ CSPâ­â­â­â­                              â”‚
// â”‚ é¢˜å‹: LeetCode 300, æ´›è°· P1020, CFå¸¸è€ƒ                                  â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace LIS {
    // O(nÂ²) ç»å…¸DP
    int lis_n2(vector<int>& a) {
        int n = a.size();
        vector<int> dp(n, 1);  // dp[i] = ä»¥a[i]ç»“å°¾çš„LISé•¿åº¦
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (a[j] < a[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
    
    // O(n log n) äºŒåˆ†ä¼˜åŒ– (ç«èµ›å¸¸ç”¨)
    int lis_nlogn(vector<int>& a) {
        vector<int> tail;  // tail[i] = é•¿åº¦ä¸ºi+1çš„LISçš„æœ€å°æœ«å°¾å…ƒç´ 
        
        for (int x : a) {
            // æ‰¾åˆ°ç¬¬ä¸€ä¸ª >= x çš„ä½ç½®
            auto it = lower_bound(tail.begin(), tail.end(), x);
            if (it == tail.end()) {
                tail.push_back(x);  // æ¯”æ‰€æœ‰éƒ½å¤§ï¼Œæ–°å¢é•¿åº¦
            } else {
                *it = x;  // æ›¿æ¢ä¸ºæ›´å°çš„æœ«å°¾
            }
        }
        return tail.size();
    }
    
    // å˜å½¢: æœ€é•¿ä¸ä¸‹é™å­åºåˆ— (æ”¹ < ä¸º <=, lower_bound æ”¹ upper_bound)
    // å˜å½¢: æœ€é•¿ä¸‹é™å­åºåˆ— (åè¿‡æ¥æˆ–è€… greater)
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 1.2 æœ€é•¿å…¬å…±å­åºåˆ— (LCS) - O(nÂ·m)                                       â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ è“æ¡¥æ¯â­â­â­ CSPâ­â­â­                                  â”‚
// â”‚ é¢˜å‹: LeetCode 1143, æ´›è°· P1439                                         â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace LCS {
    int lcs(string& s, string& t) {
        int n = s.size(), m = t.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        // dp[i][j] = så‰iä¸ªå­—ç¬¦ä¸tå‰jä¸ªå­—ç¬¦çš„LCSé•¿åº¦
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s[i-1] == t[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;  // åŒ¹é…
                } else {
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  // ä¸åŒ¹é…
                }
            }
        }
        return dp[n][m];
    }
    
    // ç©ºé—´ä¼˜åŒ–: æ»šåŠ¨æ•°ç»„ O(min(n,m))
    int lcs_optimized(string& s, string& t) {
        int n = s.size(), m = t.size();
        vector<int> dp(m + 1, 0);
        
        for (int i = 1; i <= n; i++) {
            int pre = 0;  // ä¿å­˜ dp[i-1][j-1]
            for (int j = 1; j <= m; j++) {
                int tmp = dp[j];
                if (s[i-1] == t[j-1]) {
                    dp[j] = pre + 1;
                } else {
                    dp[j] = max(dp[j], dp[j-1]);
                }
                pre = tmp;
            }
        }
        return dp[m];
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. èƒŒåŒ…DP - ç‰©å“é€‰æ‹©é—®é¢˜
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 2.1 01èƒŒåŒ… - æ¯ä¸ªç‰©å“æœ€å¤šé€‰ä¸€æ¬¡                                         â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­â­ è“æ¡¥æ¯â­â­â­â­â­ CSPâ­â­â­â­â­                        â”‚
// â”‚ é¢˜å‹: æ´›è°· P1048, AcWing 2                                              â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace Knapsack01 {
    int knapsack(vector<int>& w, vector<int>& v, int W) {
        int n = w.size();
        vector<int> dp(W + 1, 0);  // dp[j] = å®¹é‡ä¸ºjæ—¶çš„æœ€å¤§ä»·å€¼
        
        for (int i = 0; i < n; i++) {
            // ã€å…³é”®ã€‘å€’åºéå†ï¼Œé¿å…é‡å¤é€‰æ‹©
            for (int j = W; j >= w[i]; j--) {
                dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
            }
        }
        return dp[W];
    }
    
    // äºŒç»´ç‰ˆæœ¬ï¼ˆæ–¹ä¾¿ç†è§£ï¼‰
    int knapsack_2d(vector<int>& w, vector<int>& v, int W) {
        int n = w.size();
        vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
        // dp[i][j] = å‰iä¸ªç‰©å“ï¼Œå®¹é‡jçš„æœ€å¤§ä»·å€¼
        
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= W; j++) {
                dp[i][j] = dp[i-1][j];  // ä¸é€‰ç¬¬iä¸ª
                if (j >= w[i-1]) {
                    dp[i][j] = max(dp[i][j], dp[i-1][j - w[i-1]] + v[i-1]);
                }
            }
        }
        return dp[n][W];
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 2.2 å®Œå…¨èƒŒåŒ… - æ¯ä¸ªç‰©å“å¯ä»¥é€‰æ— é™æ¬¡                                     â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ è“æ¡¥æ¯â­â­â­â­ CSPâ­â­â­                              â”‚
// â”‚ é¢˜å‹: æ´›è°· P1616, AcWing 3                                              â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace KnapsackComplete {
    int knapsack(vector<int>& w, vector<int>& v, int W) {
        vector<int> dp(W + 1, 0);
        
        for (int i = 0; i < w.size(); i++) {
            // ã€å…³é”®ã€‘æ­£åºéå†ï¼Œå…è®¸é‡å¤é€‰æ‹©
            for (int j = w[i]; j <= W; j++) {
                dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
            }
        }
        return dp[W];
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 2.3 å¤šé‡èƒŒåŒ… - æ¯ä¸ªç‰©å“æœ‰æ•°é‡é™åˆ¶                                       â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­ è“æ¡¥æ¯â­â­ CSPâ­â­                                      â”‚
// â”‚ é¢˜å‹: æ´›è°· P1776, AcWing 4                                              â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace KnapsackMultiple {
    // äºŒè¿›åˆ¶ä¼˜åŒ– - O(WÂ·Î£log(cnt[i]))
    int knapsack(vector<int>& w, vector<int>& v, vector<int>& cnt, int W) {
        vector<int> dp(W + 1, 0);
        
        // äºŒè¿›åˆ¶æ‹†åˆ†ï¼šå°†cnt[i]æ‹†æˆ1,2,4,...,2^k, remainder
        for (int i = 0; i < w.size(); i++) {
            int c = cnt[i];
            for (int k = 1; k <= c; k *= 2) {
                int weight = k * w[i];
                int value = k * v[i];
                // 01èƒŒåŒ…
                for (int j = W; j >= weight; j--) {
                    dp[j] = max(dp[j], dp[j - weight] + value);
                }
                c -= k;
            }
            // å¤„ç†å‰©ä½™
            if (c > 0) {
                int weight = c * w[i];
                int value = c * v[i];
                for (int j = W; j >= weight; j--) {
                    dp[j] = max(dp[j], dp[j - weight] + value);
                }
            }
        }
        return dp[W];
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. åŒºé—´DP - ä»å°åŒºé—´åˆå¹¶åˆ°å¤§åŒºé—´
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 3.1 çŸ³å­åˆå¹¶ - ç»å…¸åŒºé—´DP                                               â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ è“æ¡¥æ¯â­â­â­ CSPâ­â­â­â­                              â”‚
// â”‚ é¢˜å‹: æ´›è°· P1880, AcWing 282                                            â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace IntervalDP {
    int stoneMerge(vector<int>& stones) {
        int n = stones.size();
        vector<int> sum(n + 1, 0);
        for (int i = 0; i < n; i++) sum[i+1] = sum[i] + stones[i];
        
        vector<vector<int>> dp(n, vector<int>(n, 0));
        // dp[l][r] = åˆå¹¶åŒºé—´[l,r]çš„æœ€å°ä»£ä»·
        
        // æŒ‰åŒºé—´é•¿åº¦æšä¸¾
        for (int len = 2; len <= n; len++) {
            for (int l = 0; l + len - 1 < n; l++) {
                int r = l + len - 1;
                dp[l][r] = INT_MAX;
                // æšä¸¾åˆ†å‰²ç‚¹k
                for (int k = l; k < r; k++) {
                    dp[l][r] = min(dp[l][r], 
                                   dp[l][k] + dp[k+1][r] + sum[r+1] - sum[l]);
                }
            }
        }
        return dp[0][n-1];
    }
    
    // ç¯å½¢çŸ³å­åˆå¹¶ (ç ´ç¯æˆé“¾)
    int stoneMergeCircular(vector<int>& stones) {
        int n = stones.size();
        // å¤åˆ¶ä¸€ä»½æ¥åˆ°åé¢
        vector<int> a(stones.begin(), stones.end());
        a.insert(a.end(), stones.begin(), stones.end());
        
        vector<int> sum(2*n + 1, 0);
        for (int i = 0; i < 2*n; i++) sum[i+1] = sum[i] + a[i];
        
        vector<vector<int>> dp(2*n, vector<int>(2*n, 0));
        
        for (int len = 2; len <= n; len++) {
            for (int l = 0; l + len - 1 < 2*n; l++) {
                int r = l + len - 1;
                dp[l][r] = INT_MAX;
                for (int k = l; k < r; k++) {
                    dp[l][r] = min(dp[l][r], 
                                   dp[l][k] + dp[k+1][r] + sum[r+1] - sum[l]);
                }
            }
        }
        
        int ans = INT_MAX;
        for (int i = 0; i < n; i++) {
            ans = min(ans, dp[i][i + n - 1]);
        }
        return ans;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. æ ‘å½¢DP - åœ¨æ ‘ä¸ŠåšDP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 4.1 æ ‘çš„ç›´å¾„ - æ ‘ä¸Šæœ€é•¿è·¯å¾„                                             â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­ CSPâ­â­â­                                              â”‚
// â”‚ é¢˜å‹: æ´›è°· P3304, LeetCode 543                                          â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace TreeDP {
    vector<vector<int>> adj;
    int diameter = 0;
    
    int dfs(int u, int fa) {
        int max1 = 0, max2 = 0;  // æœ€é•¿å’Œæ¬¡é•¿è·¯å¾„
        
        for (int v : adj[u]) {
            if (v == fa) continue;
            int d = dfs(v, u) + 1;  // å­æ ‘æ·±åº¦
            
            if (d > max1) {
                max2 = max1;
                max1 = d;
            } else if (d > max2) {
                max2 = d;
            }
        }
        
        diameter = max(diameter, max1 + max2);  // æ›´æ–°ç›´å¾„
        return max1;  // è¿”å›ä»¥uä¸ºæ ¹çš„æœ€å¤§æ·±åº¦
    }
    
    // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    // â”‚ 4.2 æ ‘å½¢èƒŒåŒ… - æ ‘ä¸Šé€‰ç‚¹                                           â”‚
    // â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ CSPâ­â­â­                                      â”‚
    // â”‚ é¢˜å‹: æ´›è°· P2014 é€‰è¯¾                                            â”‚
    // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    vector<int> value;
    vector<vector<int>> dp;  // dp[u][j] = uçš„å­æ ‘é€‰jä¸ªèŠ‚ç‚¹çš„æœ€å¤§ä»·å€¼
    
    void dfs_knapsack(int u, int fa, int m) {
        dp[u][1] = value[u];  // è‡³å°‘é€‰uè‡ªå·±
        
        for (int v : adj[u]) {
            if (v == fa) continue;
            dfs_knapsack(v, u, m);
            
            // æ ‘ä¸ŠèƒŒåŒ…åˆå¹¶
            for (int j = m; j >= 1; j--) {
                for (int k = 0; k < j; k++) {
                    dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k]);
                }
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. çŠ¶æ€å‹ç¼©DP - ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºçŠ¶æ€
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 5.1 æ—…è¡Œå•†é—®é¢˜ (TSP) - ç»å…¸çŠ¶å‹DP                                       â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ CSPâ­â­â­                                            â”‚
// â”‚ é¢˜å‹: æ´›è°· P1171, LeetCode 943                                          â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace StateDP {
    int tsp(vector<vector<int>>& dist) {
        int n = dist.size();
        int FULL = (1 << n) - 1;
        vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX/2));
        // dp[mask][i] = è®¿é—®è¿‡çš„åŸå¸‚é›†åˆä¸ºmaskï¼Œå½“å‰åœ¨içš„æœ€çŸ­è·¯å¾„
        
        dp[1][0] = 0;  // ä»0å‡ºå‘
        
        for (int mask = 1; mask <= FULL; mask++) {
            for (int i = 0; i < n; i++) {
                if (!(mask & (1 << i))) continue;  // iä¸åœ¨maskä¸­
                
                for (int j = 0; j < n; j++) {
                    if (mask & (1 << j)) continue;  // jå·²è®¿é—®
                    int next_mask = mask | (1 << j);
                    dp[next_mask][j] = min(dp[next_mask][j], 
                                           dp[mask][i] + dist[i][j]);
                }
            }
        }
        
        // å›åˆ°èµ·ç‚¹
        int ans = INT_MAX;
        for (int i = 1; i < n; i++) {
            ans = min(ans, dp[FULL][i] + dist[i][0]);
        }
        return ans;
    }
    
    // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    // â”‚ 5.2 çŠ¶æ€å‹ç¼© - æ£‹ç›˜æ”¾ç½®é—®é¢˜                                       â”‚
    // â”‚ è€ƒç‚¹: XCPCâ­â­â­ CSPâ­â­                                          â”‚
    // â”‚ é¢˜å‹: æ´›è°· P1879 ç‰ç±³ç”°                                          â”‚
    // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    int cornField(vector<int>& field, int n, int m) {
        const int MOD = 1e8;
        vector<vector<long long>> dp(n + 1, vector<long long>(1 << m, 0));
        // dp[i][mask] = ç¬¬iè¡ŒçŠ¶æ€ä¸ºmaskçš„æ–¹æ¡ˆæ•°
        
        dp[0][0] = 1;
        
        for (int i = 1; i <= n; i++) {
            for (int cur = 0; cur < (1 << m); cur++) {
                // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦åˆæ³•
                if (cur & ~field[i-1]) continue;  // æœ‰åœ°é›·
                if (cur & (cur << 1)) continue;   // ç›¸é‚»
                
                for (int pre = 0; pre < (1 << m); pre++) {
                    if (cur & pre) continue;  // ä¸Šä¸‹ç›¸é‚»
                    dp[i][cur] = (dp[i][cur] + dp[i-1][pre]) % MOD;
                }
            }
        }
        
        long long ans = 0;
        for (int mask = 0; mask < (1 << m); mask++) {
            ans = (ans + dp[n][mask]) % MOD;
        }
        return ans;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 6. æ•°ä½DP - ç»Ÿè®¡åŒºé—´å†…æ»¡è¶³æ¡ä»¶çš„æ•°
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 6.1 æ•°ä½DPæ¨¡æ¿ - ç»Ÿè®¡[L, R]ä¸­æ»¡è¶³æ¡ä»¶çš„æ•°                               â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ CFâ­â­â­â­ CSPâ­â­â­                                â”‚
// â”‚ é¢˜å‹: æ´›è°· P2602, AcWing 338                                            â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace DigitDP {
    long long dp[20][10][2];  // dp[pos][last][limit]
    string num;
    
    // ç»Ÿè®¡ä¸å«62çš„æ•°ï¼ˆä¾‹é¢˜ï¼‰
    long long dfs(int pos, int last, bool limit) {
        if (pos == num.size()) return 1;
        if (!limit && dp[pos][last][0] != -1) return dp[pos][last][0];
        
        int up = limit ? (num[pos] - '0') : 9;
        long long res = 0;
        
        for (int i = 0; i <= up; i++) {
            if (last == 6 && i == 2) continue;  // ä¸èƒ½æœ‰62
            res += dfs(pos + 1, i, limit && (i == up));
        }
        
        if (!limit) dp[pos][last][0] = res;
        return res;
    }
    
    long long solve(long long x) {
        if (x < 0) return 0;
        num = to_string(x);
        memset(dp, -1, sizeof(dp));
        return dfs(0, 0, true);
    }
    
    // åŒºé—´æŸ¥è¯¢: solve(R) - solve(L - 1)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 7. DPä¼˜åŒ–æŠ€å·§
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 7.1 å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–DP - æ»‘åŠ¨çª—å£æœ€å€¼                                       â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ CSPâ­â­â­                                            â”‚
// â”‚ é¢˜å‹: æ´›è°· P1886, å¤šé‡èƒŒåŒ…ä¼˜åŒ–                                          â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace MonotonicQueueDP {
    // æ»‘åŠ¨çª—å£æœ€å¤§å€¼
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;  // å•è°ƒé€’å‡é˜Ÿåˆ—ï¼ˆå­˜ä¸‹æ ‡ï¼‰
        vector<int> res;
        
        for (int i = 0; i < nums.size(); i++) {
            // ç§»é™¤è¿‡æœŸå…ƒç´ 
            while (!dq.empty() && dq.front() < i - k + 1) {
                dq.pop_front();
            }
            // ç»´æŠ¤å•è°ƒæ€§
            while (!dq.empty() && nums[dq.back()] <= nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            
            if (i >= k - 1) {
                res.push_back(nums[dq.front()]);
            }
        }
        return res;
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 7.2 æ–œç‡ä¼˜åŒ–(CHT) - å‡¸åŒ…ä¼˜åŒ–DPè½¬ç§»                                      â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­â­ çœé€‰ä»¥ä¸Š                                          â”‚
// â”‚ é¢˜å‹: æ´›è°· P3195 ç©å…·è£…ç®±                                               â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace SlopeOptimization {
    // ç©å…·è£…ç®±æ¨¡æ¿
    // dp[i] = min{dp[j] + (sum[i] - sum[j] + i - j - 1 - L)^2}
    // éœ€è¦æ–œç‡ä¼˜åŒ–ï¼Œè¿™é‡Œä»…å±•ç¤ºæ€è·¯
    
    /*
     * æ ¸å¿ƒæ€æƒ³ï¼š
     * 1. å°†DPè½¬ç§»æ–¹ç¨‹å˜å½¢ä¸º y = kx + b çš„å½¢å¼
     * 2. ç»´æŠ¤ä¸‹å‡¸å£³ï¼ˆæˆ–ä¸Šå‡¸å£³ï¼‰
     * 3. ç”¨äºŒåˆ†/åŒæŒ‡é’ˆæ‰¾æœ€ä¼˜è½¬ç§»ç‚¹
     * 
     * ä½¿ç”¨åœºæ™¯ï¼š
     * - è½¬ç§»æ–¹ç¨‹æ˜¯äºŒæ¬¡å‡½æ•°
     * - å†³ç­–å•è°ƒæ€§
     */
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ã€è€ƒå‰é€Ÿè®°å¡ç‰‡ã€‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/*
 * 1. èƒŒåŒ…DP:
 *    01èƒŒåŒ…: å€’åº  dp[j] = max(dp[j], dp[j-w] + v)
 *    å®Œå…¨èƒŒåŒ…: æ­£åº  dp[j] = max(dp[j], dp[j-w] + v)
 * 
 * 2. LIS:
 *    O(nÂ²): dp[i] = max{dp[j] + 1} where a[j] < a[i]
 *    O(nlogn): lower_bound ç»´æŠ¤tailæ•°ç»„
 * 
 * 3. åŒºé—´DP:
 *    æŒ‰é•¿åº¦æšä¸¾: for len, for l, for k (åˆ†å‰²ç‚¹)
 *    dp[l][r] = min{dp[l][k] + dp[k+1][r] + cost}
 * 
 * 4. æ ‘å½¢DP:
 *    ååºéå†: å…ˆé€’å½’å­æ ‘ï¼Œå†æ›´æ–°çˆ¶èŠ‚ç‚¹
 * 
 * 5. çŠ¶å‹DP:
 *    maskè¡¨ç¤ºé›†åˆ: (1<<i) æ£€æŸ¥ç¬¬iä½
 *    æšä¸¾å­é›†: for sub in mask: sub = (sub - 1) & mask
 * 
 * 6. æ•°ä½DP:
 *    dfs(pos, state, limit, lead_zero)
 *    è®°å¿†åŒ–: åªè®°å½•élimitçš„çŠ¶æ€
 */
