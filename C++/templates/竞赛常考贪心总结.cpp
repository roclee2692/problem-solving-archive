/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *                          ç«èµ›å¸¸è€ƒè´ªå¿ƒç±»å‹æ€»ç»“
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * é€‚ç”¨æ¯”èµ›ï¼šXCPCã€è“æ¡¥æ¯ã€CSPã€Codeforcesã€AtCoder
 * 
 * è€ƒé¢‘æ’åºï¼š
 *   ğŸ”¥ğŸ”¥ğŸ”¥ æ’åºè´ªå¿ƒã€åŒºé—´è´ªå¿ƒ (å¿…ä¼šï¼Œé€åˆ†é¢˜)
 *   ğŸ”¥ğŸ”¥   åæ‚”è´ªå¿ƒã€è´ªå¿ƒæ„é€  (é«˜é¢‘ï¼Œæ‹‰åˆ†é¡¹)
 *   ğŸ”¥     é‚»é¡¹äº¤æ¢ã€åŒæŒ‡é’ˆè´ªå¿ƒ (è¿›é˜¶)
 * 
 * æ ¸å¿ƒï¼šå±€éƒ¨æœ€ä¼˜ â†’ å…¨å±€æœ€ä¼˜ (éœ€è¯æ˜æ­£ç¡®æ€§)
 */

#include <bits/stdc++.h>
using namespace std;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. æ’åºè´ªå¿ƒ - æŒ‰å…³é”®å­—æ’åºåè´ªå¿ƒé€‰æ‹©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 1.1 æ´»åŠ¨é€‰æ‹©é—®é¢˜ - æŒ‰ç»“æŸæ—¶é—´æ’åº                                       â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­â­ è“æ¡¥æ¯â­â­â­â­â­ CSPâ­â­â­â­                        â”‚
// â”‚ é¢˜å‹: LeetCode 435, æ´›è°· P2404, ç»å…¸è´ªå¿ƒ                                â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace ActivitySelection {
    struct Activity {
        int start, end;
        bool operator<(const Activity& a) const {
            return end < a.end;  // æŒ‰ç»“æŸæ—¶é—´æ’åº
        }
    };
    
    int maxActivities(vector<Activity>& activities) {
        sort(activities.begin(), activities.end());
        
        int count = 0;
        int lastEnd = -1;
        
        for (auto& a : activities) {
            if (a.start >= lastEnd) {  // ä¸å†²çª
                count++;
                lastEnd = a.end;  // æ›´æ–°ç»“æŸæ—¶é—´
            }
        }
        return count;
    }
    
    // å˜å½¢: æœ€å°‘ä¼šè®®å®¤æ•°é‡ (ç”¨å †ç»´æŠ¤ç»“æŸæ—¶é—´)
    int minMeetingRooms(vector<Activity>& meetings) {
        sort(meetings.begin(), meetings.end(), 
             [](auto& a, auto& b) { return a.start < b.start; });
        
        priority_queue<int, vector<int>, greater<int>> pq;  // æœ€å°å †
        
        for (auto& m : meetings) {
            if (!pq.empty() && pq.top() <= m.start) {
                pq.pop();  // é‡Šæ”¾ä¼šè®®å®¤
            }
            pq.push(m.end);  // å ç”¨ä¼šè®®å®¤
        }
        return pq.size();
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 1.2 æ’é˜Ÿæ‰“æ°´ - æŒ‰æ—¶é—´ä»å°åˆ°å¤§æ’åº                                       â”‚
// â”‚ è€ƒç‚¹: è“æ¡¥æ¯â­â­â­â­â­ XCPCâ­â­â­                                        â”‚
// â”‚ é¢˜å‹: æ´›è°· P1223                                                        â”‚
// â”‚ è¯æ˜: äº¤æ¢è®ºè¯ - è‹¥ a[i] > a[i+1]ï¼Œäº¤æ¢åæ€»æ—¶é—´æ›´å°                     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace QueueWater {
    long long minTotalTime(vector<int>& time) {
        sort(time.begin(), time.end());  // ä»å°åˆ°å¤§
        
        long long total = 0;
        long long wait = 0;
        
        for (int t : time) {
            total += wait;  // ç­‰å¾…æ—¶é—´
            wait += t;      // ä¸‹ä¸€ä¸ªäººçš„ç­‰å¾…æ—¶é—´å¢åŠ 
        }
        return total;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. åŒºé—´è´ªå¿ƒ - åŒºé—´ç«¯ç‚¹æ’åº
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 2.1 åŒºé—´é€‰ç‚¹ - æœ€å°‘ç‚¹è¦†ç›–æ‰€æœ‰åŒºé—´                                       â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ CSPâ­â­â­                                            â”‚
// â”‚ é¢˜å‹: æ´›è°· P1803, AcWing 905                                            â”‚
// â”‚ ç­–ç•¥: æŒ‰å³ç«¯ç‚¹æ’åºï¼Œæ¯æ¬¡é€‰å³ç«¯ç‚¹                                        â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace IntervalPoint {
    int minPoints(vector<pair<int,int>>& intervals) {
        sort(intervals.begin(), intervals.end(), 
             [](auto& a, auto& b) { return a.second < b.second; });
        
        int count = 0;
        int lastPoint = INT_MIN;
        
        for (auto [l, r] : intervals) {
            if (l > lastPoint) {  // éœ€è¦æ–°çš„ç‚¹
                count++;
                lastPoint = r;  // è´ªå¿ƒé€‰å³ç«¯ç‚¹
            }
        }
        return count;
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 2.2 åŒºé—´è¦†ç›– - æœ€å°‘åŒºé—´è¦†ç›–æ•´ä¸ªèŒƒå›´                                     â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ è“æ¡¥æ¯â­â­â­                                        â”‚
// â”‚ é¢˜å‹: LeetCode 1024, AcWing 906                                         â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace IntervalCover {
    int minIntervals(vector<pair<int,int>>& intervals, int L, int R) {
        sort(intervals.begin(), intervals.end());
        
        int count = 0;
        int current = L;  // å½“å‰éœ€è¦è¦†ç›–çš„ä½ç½®
        int i = 0;
        
        while (current < R) {
            int maxRight = current;
            
            // æ‰¾èƒ½è¦†ç›–currentçš„æœ€è¿œå³ç«¯ç‚¹
            while (i < intervals.size() && intervals[i].first <= current) {
                maxRight = max(maxRight, intervals[i].second);
                i++;
            }
            
            if (maxRight == current) return -1;  // æ— æ³•è¦†ç›–
            
            count++;
            current = maxRight;
        }
        return count;
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 2.3 åŒºé—´åˆå¹¶ - åˆå¹¶é‡å åŒºé—´                                             â”‚
// â”‚ è€ƒç‚¹: è“æ¡¥æ¯â­â­â­â­ XCPCâ­â­â­                                        â”‚
// â”‚ é¢˜å‹: LeetCode 56                                                       â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace IntervalMerge {
    vector<pair<int,int>> merge(vector<pair<int,int>>& intervals) {
        if (intervals.empty()) return {};
        
        sort(intervals.begin(), intervals.end());
        vector<pair<int,int>> res;
        res.push_back(intervals[0]);
        
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i].first <= res.back().second) {
                // é‡å ï¼Œåˆå¹¶
                res.back().second = max(res.back().second, intervals[i].second);
            } else {
                res.push_back(intervals[i]);
            }
        }
        return res;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. åæ‚”è´ªå¿ƒ - ç”¨å †ç»´æŠ¤ï¼Œå…è®¸æ’¤é”€å†³ç­–
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 3.1 è´§ä»“é€‰å€ - ä¸­ä½æ•°è´ªå¿ƒ                                               â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ CFâ­â­â­â­                                          â”‚
// â”‚ é¢˜å‹: æ´›è°· P2279, AcWing 104                                            â”‚
// â”‚ è¯æ˜: é€‰ä¸­ä½æ•°ä½¿æ€»è·ç¦»æœ€å°                                              â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace MedianGreedy {
    long long warehouseLocation(vector<int>& pos) {
        sort(pos.begin(), pos.end());
        int median = pos[pos.size() / 2];  // ä¸­ä½æ•°
        
        long long total = 0;
        for (int p : pos) {
            total += abs(p - median);
        }
        return total;
    }
    
    // äºŒç»´è´§ä»“ - xå’Œyåæ ‡åˆ†åˆ«å–ä¸­ä½æ•°
    long long warehouse2D(vector<pair<int,int>>& points) {
        vector<int> x, y;
        for (auto [px, py] : points) {
            x.push_back(px);
            y.push_back(py);
        }
        return warehouseLocation(x) + warehouseLocation(y);
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 3.2 ä»»åŠ¡åˆ†é… - åæ‚”å †                                                   â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­ AtCoderâ­â­â­â­                                      â”‚
// â”‚ é¢˜å‹: CF 865D                                                           â”‚
// â”‚ ç­–ç•¥: å…ˆè´ªå¿ƒåˆ†é…ï¼Œç”¨å †ç»´æŠ¤å¯åæ‚”çš„å†³ç­–                                  â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace RegretGreedy {
    // ä¾‹: é›‡ä½£Kä¸ªå‘˜å·¥ï¼Œæœ€å°åŒ–æˆæœ¬
    long long minCost(vector<pair<int,int>>& workers, int k) {
        // workers[i] = {cost, quality}
        sort(workers.begin(), workers.end(), 
             [](auto& a, auto& b) { 
                 return 1.0*a.first/a.second < 1.0*b.first/b.second; 
             });
        
        priority_queue<int> pq;  // å¤§æ ¹å †ï¼Œç»´æŠ¤quality
        long long sumQuality = 0;
        long long minCost = LLONG_MAX;
        
        for (auto [c, q] : workers) {
            pq.push(q);
            sumQuality += q;
            
            if (pq.size() > k) {
                sumQuality -= pq.top();  // åæ‚”ï¼šç§»é™¤qualityæœ€å¤§çš„
                pq.pop();
            }
            
            if (pq.size() == k) {
                minCost = min(minCost, sumQuality * c / q);
            }
        }
        return minCost;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. äº¤æ¢è®ºè¯è´ªå¿ƒ - é€šè¿‡äº¤æ¢ç›¸é‚»å…ƒç´ è¯æ˜
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 4.1 ç”°å¿Œèµ›é©¬ - å¯¹æŠ—æ€§è´ªå¿ƒ                                               â”‚
// â”‚ è€ƒç‚¹: è“æ¡¥æ¯â­â­â­â­ XCPCâ­â­â­                                        â”‚
// â”‚ ç­–ç•¥: åŒæ–¹æ’åºï¼ŒåŒæŒ‡é’ˆåŒ¹é…                                              â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace HorseRacing {
    int maxWins(vector<int>& tian, vector<int>& king) {
        sort(tian.begin(), tian.end());
        sort(king.begin(), king.end());
        
        int wins = 0;
        int tl = 0, tr = tian.size() - 1;
        int kl = 0, kr = king.size() - 1;
        
        while (tl <= tr) {
            if (tian[tr] > king[kr]) {
                // æœ€å¼ºçš„é©¬èµ¢æœ€å¼ºçš„
                wins++;
                tr--; kr--;
            } else if (tian[tr] < king[kr]) {
                // æœ€å¼±çš„é©¬è¾“æœ€å¼ºçš„
                tl++; kr--;
            } else {
                // ç›¸ç­‰ï¼Œç”¨æœ€å¼±çš„é©¬æ¢æœ€å¼ºçš„
                if (tian[tl] > king[kl]) {
                    wins++;
                    tl++; kl++;
                } else {
                    tl++; kr--;
                }
            }
        }
        return wins;
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 4.2 å›½ç‹æ¸¸æˆ - é‚»é¡¹äº¤æ¢è¯æ˜                                             â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­â­â­ NOIPæé«˜ç»„                                        â”‚
// â”‚ é¢˜å‹: æ´›è°· P1080                                                        â”‚
// â”‚ è¯æ˜: ç›¸é‚»ä¸¤äººäº¤æ¢åæ¯”è¾ƒæœ€å¤§å€¼                                          â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace KingGame {
    struct Person {
        int a, b;  // å·¦æ‰‹ã€å³æ‰‹é‡‘å¸æ•°
        bool operator<(const Person& p) const {
            return a * b < p.a * p.b;  // æŒ‰ a*b æ’åº
        }
    };
    
    // è¯æ˜: è‹¥ç¬¬iä¸ªäººåœ¨ç¬¬i+1ä¸ªäººå‰é¢
    // max{prod/b[i], prod*a[i]/b[i+1]} 
    // vs 
    // max{prod/b[i+1], prod*a[i+1]/b[i]}
    // å±•å¼€å¾—åˆ° a[i]*b[i] < a[i+1]*b[i+1] æ—¶é¡ºåºæœ€ä¼˜
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. åŒæŒ‡é’ˆè´ªå¿ƒ - ä¸¤ç«¯æ”¶ç¼©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 5.1 æ¥é›¨æ°´ - ç»å…¸åŒæŒ‡é’ˆ                                                 â”‚
// â”‚ è€ƒç‚¹: è“æ¡¥æ¯â­â­â­ XCPCâ­â­â­                                          â”‚
// â”‚ é¢˜å‹: LeetCode 42                                                       â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace TwoPointerGreedy {
    int trap(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int leftMax = 0, rightMax = 0;
        int water = 0;
        
        while (l < r) {
            if (height[l] < height[r]) {
                // å¤„ç†å·¦è¾¹
                if (height[l] >= leftMax) {
                    leftMax = height[l];
                } else {
                    water += leftMax - height[l];
                }
                l++;
            } else {
                // å¤„ç†å³è¾¹
                if (height[r] >= rightMax) {
                    rightMax = height[r];
                } else {
                    water += rightMax - height[r];
                }
                r--;
            }
        }
        return water;
    }
    
    // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    // â”‚ 5.2 ç››æ°´æœ€å¤šçš„å®¹å™¨                                                â”‚
    // â”‚ é¢˜å‹: LeetCode 11                                                â”‚
    // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int maxWater = 0;
        
        while (l < r) {
            int h = min(height[l], height[r]);
            maxWater = max(maxWater, h * (r - l));
            
            // ç§»åŠ¨è¾ƒçŸ®çš„ä¸€è¾¹
            if (height[l] < height[r]) {
                l++;
            } else {
                r--;
            }
        }
        return maxWater;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 6. è´ªå¿ƒæ„é€  - é€æ­¥æ„é€ æ»¡è¶³æ¡ä»¶çš„åºåˆ—
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 6.1 å­—å…¸åºæœ€å° - å»é™¤Kä½æ•°å­—                                            â”‚
// â”‚ è€ƒç‚¹: CFâ­â­â­â­â­ XCPCâ­â­â­â­                                        â”‚
// â”‚ é¢˜å‹: LeetCode 402                                                      â”‚
// â”‚ ç­–ç•¥: å•è°ƒæ ˆç»´æŠ¤é€’å¢åºåˆ—                                                â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace ConstructionGreedy {
    string removeKdigits(string num, int k) {
        string res;
        
        for (char c : num) {
            // è´ªå¿ƒ: ä¿æŒé€’å¢ï¼Œé‡åˆ°æ›´å°çš„æ•°å°±å¼¹å‡º
            while (!res.empty() && k > 0 && res.back() > c) {
                res.pop_back();
                k--;
            }
            res.push_back(c);
        }
        
        // è¿˜éœ€è¦åˆ é™¤
        while (k > 0) {
            res.pop_back();
            k--;
        }
        
        // å»é™¤å‰å¯¼0
        int i = 0;
        while (i < res.size() && res[i] == '0') i++;
        res = res.substr(i);
        
        return res.empty() ? "0" : res;
    }
    
    // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    // â”‚ 6.2 å»é™¤é‡å¤å­—æ¯ (ä¿æŒå­—å…¸åºæœ€å°)                                 â”‚
    // â”‚ é¢˜å‹: LeetCode 316                                               â”‚
    // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    string removeDuplicateLetters(string s) {
        vector<int> count(26, 0);
        vector<bool> used(26, false);
        
        for (char c : s) count[c - 'a']++;
        
        string res;
        for (char c : s) {
            count[c - 'a']--;
            
            if (used[c - 'a']) continue;
            
            // è´ªå¿ƒ: å¦‚æœæ ˆé¡¶å­—ç¬¦å¤§äºå½“å‰å­—ç¬¦ï¼Œä¸”åé¢è¿˜æœ‰ï¼Œå°±å¼¹å‡º
            while (!res.empty() && res.back() > c && 
                   count[res.back() - 'a'] > 0) {
                used[res.back() - 'a'] = false;
                res.pop_back();
            }
            
            res.push_back(c);
            used[c - 'a'] = true;
        }
        return res;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 7. åˆ†æ•°/æ¯”ä¾‹è´ªå¿ƒ - æŒ‰æ€§ä»·æ¯”æ’åº
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 7.1 åˆ†æ•°èƒŒåŒ… - å¯ä»¥æ‹¿éƒ¨åˆ†ç‰©å“                                           â”‚
// â”‚ è€ƒç‚¹: è“æ¡¥æ¯â­â­â­â­ XCPCâ­â­â­                                        â”‚
// â”‚ æ³¨æ„: 01èƒŒåŒ…ä¸èƒ½ç”¨è´ªå¿ƒï¼Œå¿…é¡»ç”¨DP                                        â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace FractionalKnapsack {
    struct Item {
        int weight, value;
        double ratio() const { return 1.0 * value / weight; }
        bool operator<(const Item& i) const {
            return ratio() > i.ratio();  // æŒ‰æ€§ä»·æ¯”é™åº
        }
    };
    
    double maxValue(vector<Item>& items, int W) {
        sort(items.begin(), items.end());
        
        double totalValue = 0;
        int remain = W;
        
        for (auto& item : items) {
            if (remain >= item.weight) {
                // å®Œå…¨æ‹¿èµ°
                totalValue += item.value;
                remain -= item.weight;
            } else {
                // æ‹¿ä¸€éƒ¨åˆ†
                totalValue += item.ratio() * remain;
                break;
            }
        }
        return totalValue;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 8. ç‰¹æ®Šè´ªå¿ƒæŠ€å·§
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 8.1 è·³è·ƒæ¸¸æˆ - è´ªå¿ƒç»´æŠ¤æœ€è¿œä½ç½®                                         â”‚
// â”‚ è€ƒç‚¹: è“æ¡¥æ¯â­â­â­â­ LeetCodeç»å…¸                                      â”‚
// â”‚ é¢˜å‹: LeetCode 55, 45                                                   â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace JumpGame {
    // èƒ½å¦åˆ°è¾¾ç»ˆç‚¹
    bool canJump(vector<int>& nums) {
        int maxReach = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i > maxReach) return false;  // åˆ°ä¸äº†i
            maxReach = max(maxReach, i + nums[i]);
        }
        return true;
    }
    
    // æœ€å°‘è·³è·ƒæ¬¡æ•°
    int minJumps(vector<int>& nums) {
        int jumps = 0;
        int curEnd = 0;      // å½“å‰è·³è·ƒèƒ½åˆ°çš„æœ€è¿œ
        int curFarthest = 0; // ä¸‹ä¸€è·³èƒ½åˆ°çš„æœ€è¿œ
        
        for (int i = 0; i < nums.size() - 1; i++) {
            curFarthest = max(curFarthest, i + nums[i]);
            
            if (i == curEnd) {  // å¿…é¡»è·³äº†
                jumps++;
                curEnd = curFarthest;
            }
        }
        return jumps;
    }
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 8.2 åŠ æ²¹ç«™ - ç¯å½¢è´ªå¿ƒ                                                   â”‚
// â”‚ è€ƒç‚¹: XCPCâ­â­â­ LeetCodeâ­â­â­â­                                      â”‚
// â”‚ é¢˜å‹: LeetCode 134                                                      â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
namespace GasStation {
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int totalGas = 0, totalCost = 0;
        int tank = 0, start = 0;
        
        for (int i = 0; i < gas.size(); i++) {
            totalGas += gas[i];
            totalCost += cost[i];
            tank += gas[i] - cost[i];
            
            if (tank < 0) {
                // ä»i+1é‡æ–°å¼€å§‹
                start = i + 1;
                tank = 0;
            }
        }
        
        return totalGas >= totalCost ? start : -1;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ã€è€ƒå‰é€Ÿè®°å¡ç‰‡ã€‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/*
 * ã€è´ªå¿ƒæ­£ç¡®æ€§è¯æ˜æ–¹æ³•ã€‘
 * 1. äº¤æ¢è®ºè¯: è¯æ˜äº¤æ¢ä»»æ„é€†åºå¯¹ä¼šå˜å·®
 * 2. åè¯æ³•: å‡è®¾è´ªå¿ƒè§£ä¸æ˜¯æœ€ä¼˜ï¼Œæ¨å‡ºçŸ›ç›¾
 * 3. å½’çº³æ³•: è¯æ˜æ¯æ­¥ä¿æŒæœ€ä¼˜æ€§è´¨
 * 
 * ã€å¸¸è§è´ªå¿ƒç­–ç•¥ã€‘
 * 1. æ’åºè´ªå¿ƒ: æ‰¾æ­£ç¡®çš„æ’åºå…³é”®å­—
 *    - åŒºé—´: æŒ‰ç»“æŸæ—¶é—´ã€å¼€å§‹æ—¶é—´ã€é•¿åº¦
 *    - ä»»åŠ¡: æŒ‰æ—¶é—´ã€ä»£ä»·ã€æ¯”ä¾‹
 * 
 * 2. åŒºé—´è´ªå¿ƒ:
 *    - é€‰ç‚¹: æŒ‰å³ç«¯ç‚¹æ’åºï¼Œé€‰å³ç«¯ç‚¹
 *    - è¦†ç›–: æŒ‰å·¦ç«¯ç‚¹æ’åºï¼Œé€‰æœ€è¿œå³ç«¯ç‚¹
 * 
 * 3. åæ‚”è´ªå¿ƒ:
 *    - ç”¨å †ç»´æŠ¤å†³ç­–
 *    - å¤§æ ¹å †: åæ‚”åˆ é™¤æœ€å¤§çš„
 *    - å°æ ¹å †: åæ‚”åˆ é™¤æœ€å°çš„
 * 
 * 4. æ„é€ è´ªå¿ƒ:
 *    - å­—å…¸åº: å•è°ƒæ ˆç»´æŠ¤
 *    - é€æ­¥æ„é€ ï¼Œæ¯æ­¥é€‰å½“å‰æœ€ä¼˜
 * 
 * 5. åŒæŒ‡é’ˆ:
 *    - ä»ä¸¤ç«¯æ”¶ç¼©
 *    - ç§»åŠ¨è¾ƒå°/è¾ƒå¤§çš„ä¸€ç«¯
 * 
 * ã€è´ªå¿ƒvs DPã€‘
 * - 01èƒŒåŒ…: DP (è´ªå¿ƒé”™è¯¯)
 * - åˆ†æ•°èƒŒåŒ…: è´ªå¿ƒ (æŒ‰æ€§ä»·æ¯”)
 * - æ‰¾é›¶é’±: ç‰¹æ®Šå¸å€¼ç”¨è´ªå¿ƒï¼Œä¸€èˆ¬ç”¨DP
 * 
 * ã€è“æ¡¥æ¯æç¤ºã€‘
 * - ç®€å•é¢˜: ç›´æ¥æ’åº + è´ªå¿ƒ
 * - ä¸éœ€è¦ä¸¥æ ¼è¯æ˜
 * - å¯ä»¥æ‰“è¡¨éªŒè¯å°æ•°æ®
 * 
 * ã€XCPC/CFæç¤ºã€‘
 * - å¿…é¡»ä¸¥æ ¼è¯æ˜
 * - æ³¨æ„åä¾‹
 * - æ„é€ é¢˜å¤šç»ƒ
 */
