/*
 * 【树状数组/芬威克树】- 区间查询与单点更新
 * Binary Indexed Tree / Fenwick Tree
 * 时间复杂度：O(log n) 单点更新 + O(log n) 区间查询
 * 空间复杂度：O(n)
 * 
 * 适用场景：
 *   - 区间和查询
 *   - 单点更新
 *   - 逆序对计数
 *   - 比线段树轻量（常数小）
 * 
 * 模板题：
 *   - 洛谷 P3374 - 【模板】树状数组 1
 *   - Codeforces 1155D - Neko and Enticement
 */

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

class BIT {
private:
    vector<ll> tree;
    int n;
    
    int lowbit(int x) {
        return x & (-x);
    }
    
public:
    BIT(int n) : n(n), tree(n + 1, 0) {}
    
    void update(int pos, ll val) {
        for (int i = pos; i <= n; i += lowbit(i)) {
            tree[i] += val;
        }
    }
    
    ll query(int pos) {
        ll res = 0;
        for (int i = pos; i > 0; i -= lowbit(i)) {
            res += tree[i];
        }
        return res;
    }
    
    // 区间查询 [l, r]
    ll rangeQuery(int l, int r) {
        if (l > r) return 0;
        return query(r) - (l > 1 ? query(l - 1) : 0);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, q;
    cin >> n >> q;
    
    BIT bit(n);
    
    for (int i = 1; i <= n; i++) {
        ll x;
        cin >> x;
        bit.update(i, x);
    }
    
    for (int i = 0; i < q; i++) {
        int op;
        cin >> op;
        
        if (op == 1) {
            // 单点更新
            int pos;
            ll val;
            cin >> pos >> val;
            ll old = bit.rangeQuery(pos, pos);
            bit.update(pos, val - old);
        } else {
            // 区间查询
            int l, r;
            cin >> l >> r;
            cout << bit.rangeQuery(l, r) << "\n";
        }
    }
    
    return 0;
}

/*
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║                          树状数组核心原理                                    ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 * 
 * 【核心思想】
 * 通过二进制分组，让每个节点管理不同长度的区间，实现 O(log n) 的高效操作
 * 
 * 【数据结构设计】
 * tree[i] 管理的区间长度 = lowbit(i)
 * 
 * 示例（n=8）：
 *   tree[1] 管理 [1, 1]，长度 1 (lowbit(1) = 0001 = 1)
 *   tree[2] 管理 [1, 2]，长度 2 (lowbit(2) = 0010 = 2)
 *   tree[3] 管理 [3, 3]，长度 1 (lowbit(3) = 0001 = 1)
 *   tree[4] 管理 [1, 4]，长度 4 (lowbit(4) = 0100 = 4)
 *   tree[5] 管理 [5, 5]，长度 1 (lowbit(5) = 0001 = 1)
 *   tree[6] 管理 [5, 6]，长度 2 (lowbit(6) = 0010 = 2)
 *   tree[7] 管理 [7, 7]，长度 1 (lowbit(7) = 0001 = 1)
 *   tree[8] 管理 [1, 8]，长度 8 (lowbit(8) = 1000 = 8)
 * 
 * 【树形结构】
 *         8 [1-8]
 *        /  \
 *       4    12
 *    [1-4]  [9-12]
 *     / \    / \
 *    2   6  10  14
 *  [1-2][5-6]
 *   / \  / \
 *  1  3 5  7
 * 
 * 【关键操作】
 * 
 * 1. lowbit(x) = x & (-x)：提取最低位的 1
 *    原理：-x = ~x + 1（补码：按位取反加1）
 *    
 *    例子：x = 12 (二进制 1100)
 *      x     = 0000 1100
 *      ~x    = 1111 0011
 *      -x    = 1111 0100 (补码)
 *      x&-x  = 0000 0100 = 4 ✓ 提取了最低位的1
 *    
 *    为什么有效？
 *      - 最低位1右边都是0，取反后是1，加1后进位变回0
 *      - 最低位1本身：取反后是0，加1进位后变回1
 *      - 最低位1左边：取反后与原值相反，&运算后全为0
 * 
 * 2. update(pos, val)：单点更新，沿 i += lowbit(i) 向上更新
 *    路径：3 → 4 → 8 → 16 → ...
 *    
 *    例子：更新位置 3
 *      i = 3 (0011) → lowbit(3) = 1 → 3 + 1 = 4
 *      i = 4 (0100) → lowbit(4) = 4 → 4 + 4 = 8
 *      i = 8 (1000) → lowbit(8) = 8 → 8 + 8 = 16
 *    
 *    为什么向上？父节点管辖的区间包含子节点
 * 
 * 3. query(pos)：前缀和查询，沿 i -= lowbit(i) 向下查询
 *    路径：7 → 6 → 4 → 0
 *    
 *    例子：查询前7项和
 *      i = 7 (0111) → lowbit(7) = 1 → 7 - 1 = 6 → res += tree[7] [7,7]
 *      i = 6 (0110) → lowbit(6) = 2 → 6 - 2 = 4 → res += tree[6] [5,6]
 *      i = 4 (0100) → lowbit(4) = 4 → 4 - 4 = 0 → res += tree[4] [1,4]
 *      合计：[1,4] + [5,6] + [7,7] = [1,7] ✓
 *    
 *    为什么向下？通过拆分区间精确覆盖 [1, pos]
 * 
 * 4. rangeQuery(l, r)：区间查询
 *    原理：[l, r] = [1, r] - [1, l-1]
 * 
 * 5. 位置是 1-indexed（传统约定）
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║                      与其他数据结构的对比                                    ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 * 
 * 【树状数组 vs 差分数组】
 * 
 * 差分数组（Difference Array）：
 *   原理：d[i] = a[i] - a[i-1]
 *   ✅ 区间修改 O(1)：[l,r] 加 x，只需 d[l]+=x, d[r+1]-=x
 *   ❌ 单点查询 O(n)：需要累加前缀和
 *   适用：大量区间修改 + 最后统一查询
 * 
 * 树状数组：
 *   原理：二进制分组
 *   ✅ 单点更新 O(log n)
 *   ✅ 区间查询 O(log n)
 *   ❌ 区间修改需转换（或用差分BIT）
 *   适用：频繁单点更新 + 区间查询
 * 
 * 对比表格：
 *   ┌─────────┬──────────┬──────────┐
 *   │  操作   │  差分数组 │ 树状数组  │
 *   ├─────────┼──────────┼──────────┤
 *   │单点更新 │   O(1)   │ O(log n) │
 *   │区间修改 │   O(1)   │ O(log n) │
 *   │单点查询 │   O(n)   │ O(log n) │
 *   │区间查询 │   O(n)   │ O(log n) │
 *   └─────────┴──────────┴──────────┘
 * 
 * 【树状数组 vs 线段树】
 * 
 * 线段树（Segment Tree）：
 *   原理：完全二叉树，每个节点管理一个区间
 *   ✅ 区间修改 O(log n)（懒标记）
 *   ✅ 区间查询 O(log n)
 *   ✅ 支持多种操作（和/最值/GCD等）
 *   ❌ 代码复杂（50+行），常数大
 *   ❌ 空间需要 4n
 *   适用：区间修改 + 区间查询，需要维护最值/GCD等
 * 
 * 树状数组：
 *   原理：二进制索引
 *   ✅ 代码简洁（10行左右）
 *   ✅ 常数小，速度快 2-3 倍
 *   ✅ 空间只需 n
 *   ❌ 只支持可逆操作（加减、异或）
 *   ❌ 不支持区间最值（无法高效维护）
 *   适用：单点更新 + 区间和查询，需要速度和简洁性
 * 
 * 对比表格：
 *   ┌─────────┬──────────┬──────────┐
 *   │  特性   │  树状数组 │  线段树   │
 *   ├─────────┼──────────┼──────────┤
 *   │ 代码量  │   10行   │   50+行  │
 *   │单点更新 │ O(log n) │ O(log n) │
 *   │区间修改 │  需转换  │ O(log n) │
 *   │区间和   │ O(log n) │ O(log n) │
 *   │区间最值 │ ❌不支持 │ ✅支持   │
 *   │常数因子 │    小    │    大    │
 *   │空间复杂度│   O(n)  │  O(4n)   │
 *   │学习难度 │   ⭐⭐   │  ⭐⭐⭐⭐  │
 *   └─────────┴──────────┴──────────┘
 * 
 * 【为什么树状数组比线段树快？】
 *   1. 常数因子小：每次操作约 log₂(n) 次循环 vs 4·log₂(n) 次递归
 *   2. 缓存友好：数组连续存储 vs 树形跳跃访问
 *   3. 代码简洁：无需递归，循环实现 vs 递归+懒标记
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║                          选择建议                                          ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 * 
 * 差分数组：
 *   ✓ 场景：大量区间修改 + 最后统一查询
 *   ✓ 优势：区间修改 O(1)
 *   ✓ 例子：扫描线算法
 * 
 * 树状数组：
 *   ✓ 场景：频繁单点更新 + 区间和查询
 *   ✓ 优势：代码简洁，速度快
 *   ✓ 例子：逆序对计数、动态前缀和
 * 
 * 线段树：
 *   ✓ 场景：区间修改 + 区间查询（和/最值/GCD）
 *   ✓ 优势：功能强大，支持各种操作
 *   ✓ 例子：RMQ问题、区间最值查询
 * 
 * 【记忆口诀】
 *   - 只改不查 → 差分
 *   - 点改区查（和）→ 树状数组
 *   - 区改区查（任意）→ 线段树
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║                          常见变体                                          ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 * 
 * 1. 差分树状数组：支持区间修改 + 单点查询
 *    原理：在树状数组上维护差分数组
 * 
 * 2. 二维树状数组：矩形区域求和
 *    应用：二维前缀和、矩形计数
 * 
 * 3. 权值树状数组 + 二分：动态第 k 小
 *    应用：动态中位数、区间第 k 小
 * 
 * 4. 树状数组 + 主席树：带修改的区间第 k 小
 *    应用：静态区间第 k 小的动态版本
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║                          提交前检查                                        ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 * 
 * ✓ lowbit 公式是否正确：x & (-x)
 * ✓ 索引是否 1-indexed
 * ✓ update 方向：i += lowbit(i) 向上
 * ✓ query 方向：i -= lowbit(i) 向下
 * ✓ rangeQuery 边界：l > r 返回 0
 * ✓ 数组大小：n+1（下标从1开始）
 */
