/*
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║                     线段树（Segment Tree）详解                              ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 * 
 * 【核心思想】
 * 任何一个区间 [L, R] 都可以被拆分成树上的少数几个（O(log n)个）节点所代表的
 * 子区间的组合。这样，我们对区间的操作就可以转化为对这几个节点的操作，从而
 * 大大提高了效率。
 * 
 * 【时间复杂度】
 * - 建树：O(n)
 * - 单点/区间查询：O(log n)
 * - 单点/区间更新：O(log n)
 * 
 * 【空间复杂度】
 * - O(4n)：需要 4 倍空间存储完全二叉树
 * 
 * 【核心概念：懒标记（Lazy Propagation）】
 * "这活儿先不干，打个条子记下来，等真需要的时候再说。"
 * 
 * 懒标记的作用：
 * - 区间修改时不立即更新所有子节点
 * - 只在父节点打个标记（lazy），记录"还有修改没执行"
 * - 等到真正需要访问子节点时，再把标记下推（push_down）
 * - 大幅减少不必要的递归，提高效率
 * 
 * 【树形结构】
 * 以 n=8 为例：
 *                [1,8]
 *               /      \
 *           [1,4]      [5,8]
 *           /   \      /    \
 *        [1,2] [3,4] [5,6] [7,8]
 *        /  \  /  \  /  \  /  \
 *      [1] [2][3][4][5][6][7][8]
 * 
 * 节点编号规则（从1开始）：
 * - 节点 u 的左子节点：u << 1（即 u * 2）
 * - 节点 u 的右子节点：(u << 1) | 1（即 u * 2 + 1）
 * 
 * 【适用场景】
 * ✅ 区间求和/最值
 * ✅ 区间更新（加法/乘法/赋值）
 * ✅ 复杂区间查询（GCD、区间历史最值等）
 * ✅ 比树状数组灵活，支持更多操作
 * 
 * 【模板题】
 * - 洛谷 P3372 - 【模板】线段树 1
 * - Codeforces 1303E - Triangle
 */

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 5;

struct SegmentTree {
    // 【数据结构定义】
    ll tree[MAXN * 4];  // tree[u]：节点 u 维护的区间和
                        // 为什么是 4 倍？完全二叉树最坏情况需要 4n 空间
    
    ll lazy[MAXN * 4];  // lazy[u]：节点 u 的懒标记
                        // 表示"这个节点及其子树还有 lazy[u] 的修改未下推"
                        // 懒标记的本质：延迟更新，避免不必要的递归
    
    int n;              // 原始数组长度
    
    // ═══════════════════════════════════════════════════════════════════════
    // 【函数 1】push_up：向上更新（子节点合并为父节点）
    // ═══════════════════════════════════════════════════════════════════════
    // 功能：用左右子节点的信息更新当前节点
    // 时间复杂度：O(1)
    void push_up(int u) {
        tree[u] = tree[u * 2] + tree[u * 2 + 1];
        
        // 【节点编号规则】
        // u * 2 = u << 1：左子节点
        // u * 2 + 1 = (u << 1) | 1：右子节点
        
        // 【为什么 (u<<1)|1 = u*2+1？】
        // 先算 u<<1，结果是 u*2（偶数）
        // 再与 1 做按位或 |
        // 由于偶数的最低位是 0，或上 1 就是 +1
        // 所以 (u<<1)|1 = u*2+1
        
        // 【其他操作的 push_up】
        // 区间最大值：tree[u] = max(tree[u*2], tree[u*2+1]);
        // 区间最小值：tree[u] = min(tree[u*2], tree[u*2+1]);
        // 区间 GCD：tree[u] = gcd(tree[u*2], tree[u*2+1]);
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // 【函数 2】push_down：向下推送懒标记（懒惰的父亲终于要干活了）
    // ═══════════════════════════════════════════════════════════════════════
    // 功能：将父节点的懒标记下推到两个子节点
    // 时间复杂度：O(1)
    // 参数：u - 当前节点编号，len - 当前节点管辖的区间长度 (r - l + 1)
    void push_down(int u, int len) {
        // 如果没有懒标记，直接返回
        if (lazy[u] == 0) return;
        
        // 【步骤 1】将懒标记传递给左右子节点
        lazy[u * 2] += lazy[u];      // 左子节点继承父节点的懒标记
        lazy[u * 2 + 1] += lazy[u];  // 右子节点继承父节点的懒标记
        
        // 【步骤 2】更新左右子节点的区间和
        // 为什么是 lazy[u] * 区间长度？
        // 因为区间内每个元素都加了 lazy[u]，所以总和增加 lazy[u] * 元素个数
        
        tree[u * 2] += lazy[u] * (len / 2);          // 左子节点的区间长度：len/2
        tree[u * 2 + 1] += lazy[u] * (len - len / 2); // 右子节点的区间长度：len - len/2
        
        // 【为什么左子是 len/2，右子是 len-len/2？】
        // 例如：len = 5，区间 [1, 5]
        // mid = (1+5)/2 = 3
        // 左子：[1, 3]，长度 3 = len/2 (向下取整)
        // 右子：[4, 5]，长度 2 = len - len/2
        // 这样可以正确处理奇数长度的区间
        
        // 【步骤 3】清空当前节点的懒标记
        lazy[u] = 0;  // 任务已下推，清空标记
        
        // 【懒标记的本质】
        // "父亲"把活儿交给"儿子"了，自己的标记就清空
        // 儿子们拿到标记后也不立即干活，继续"懒惰"地记着
        // 等到真正需要访问儿子时，再继续下推
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // 【函数 3】build：建树（初始化线段树）
    // ═══════════════════════════════════════════════════════════════════════
    // 功能：递归建立线段树，将原始数组的值填入叶子节点
    // 时间复杂度：O(n)
    // 参数：
    //   u - 当前节点编号
    //   l, r - 当前节点管辖的区间 [l, r]
    //   arr - 原始数组（1-indexed）
    void build(int u, int l, int r, vector<ll>& arr) {
        // 【递归终止条件】叶子节点（l == r）
        if (l == r) {
            tree[u] = arr[l];  // 叶子节点直接存储数组元素
            return;
        }
        
        // 【递归过程】
        int mid = (l + r) / 2;  // 计算中点，等价于 (l + r) >> 1
        
        // 递归建立左子树：管辖区间 [l, mid]
        build(u * 2, l, mid, arr);
        
        // 递归建立右子树：管辖区间 [mid+1, r]
        build(u * 2 + 1, mid + 1, r, arr);
        
        // 【向上更新】用子节点的信息更新父节点
        push_up(u);
        
        // 【建树过程示例】n = 4，arr = [3, 2, 5, 1]
        // 
        //           节点1 [1,4] sum=11
        //           /           \
        //    节点2 [1,2]      节点3 [3,4]
        //     sum=5            sum=6
        //     /   \            /    \
        // 节点4   节点5    节点6   节点7
        // [1,1]  [2,2]    [3,3]  [4,4]
        //  =3     =2       =5     =1
        //
        // 建树顺序（后序遍历）：
        // 1. 建叶子：节点4(3), 节点5(2), 节点6(5), 节点7(1)
        // 2. push_up：节点2=3+2=5, 节点3=5+1=6
        // 3. push_up：节点1=5+6=11
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // 【函数 4】update：区间更新（区间加法）
    // ═══════════════════════════════════════════════════════════════════════
    // 功能：将区间 [ql, qr] 内的所有元素加上 val
    // 时间复杂度：O(log n)
    // 参数：
    //   u - 当前节点编号
    //   l, r - 当前节点管辖的区间
    //   ql, qr - 要修改的查询区间
    //   val - 要加的值
    void update(int u, int l, int r, int ql, int qr, ll val) {
        // 【边界检查】如果查询区间不合法，直接返回
        if (ql > qr) return;
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【情况 1】当前节点区间被查询区间完全覆盖：ql <= l && r <= qr
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 例如：要修改 [2, 5]，当前节点是 [3, 4]
        //       [3, 4] 完全在 [2, 5] 内部，直接打标记即可
        if (ql <= l && r <= qr) {
            // 更新当前节点的区间和
            tree[u] += val * (r - l + 1);
            
            // 打上懒标记（不立即更新子节点，延迟到需要时再处理）
            lazy[u] += val;
            
            // 直接返回，不再递归子节点
            // 这就是"懒标记"的核心：避免不必要的递归，提高效率
            return;
        }
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【情况 2】查询区间与当前区间有交集但不完全覆盖
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        // 【步骤 1】下推懒标记
        // 为什么要下推？因为要访问子节点了，必须确保子节点的信息是最新的
        push_down(u, r - l + 1);
        
        int mid = (l + r) / 2;
        
        // 【步骤 2】递归更新有交集的子节点
        // 只递归与查询区间有交集的子节点，提高效率
        
        if (ql <= mid) {
            // 如果查询区间的左端点 <= mid，说明左子树有交集
            update(u * 2, l, mid, ql, qr, val);
        }
        
        if (qr > mid) {
            // 如果查询区间的右端点 > mid，说明右子树有交集
            update(u * 2 + 1, mid + 1, r, ql, qr, val);
        }
        
        // 【步骤 3】向上更新当前节点
        // 子节点修改完后，父节点的值也要更新
        push_up(u);
        
        // 【update 执行过程示例】
        // 假设要修改区间 [2, 5]，加上 3
        // 
        //                [1,8]
        //               /      \
        //           [1,4]      [5,8]  ← 左子完全覆盖 [2,4]，右子部分覆盖 [5,5]
        //           /   \      /    \
        //        [1,2] [3,4] [5,6] [7,8]
        //         / \   / \
        //      [1] [2][3][4][5][6][7][8]
        //
        // 递归路径：
        // 1. 节点 [1,8]：部分覆盖 → 递归左右子
        // 2. 节点 [1,4]：部分覆盖 → 递归左右子
        // 3. 节点 [1,2]：部分覆盖 → 递归右子 [2,2]（完全覆盖，打标记）
        // 4. 节点 [3,4]：完全覆盖 → 打标记，返回
        // 5. 节点 [5,8]：部分覆盖 → 递归左子
        // 6. 节点 [5,6]：部分覆盖 → 递归左子 [5,5]（完全覆盖，打标记）
        //
        // 总共只打了 4 个标记，不需要更新所有叶子节点！
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // 【函数 5】query：区间查询（区间求和）
    // ═══════════════════════════════════════════════════════════════════════
    // 功能：查询区间 [ql, qr] 的和
    // 时间复杂度：O(log n)
    // 参数：
    //   u - 当前节点编号
    //   l, r - 当前节点管辖的区间
    //   ql, qr - 查询区间
    // 返回值：区间 [ql, qr] 的和
    ll query(int u, int l, int r, int ql, int qr) {
        // 【边界检查】如果查询区间不合法，返回 0
        if (ql > qr) return 0;
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【情况 1】当前节点区间被查询区间完全覆盖
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 例如：查询 [2, 5]，当前节点是 [3, 4]
        //       [3, 4] 完全在 [2, 5] 内，直接返回 tree[u]
        if (ql <= l && r <= qr) {
            return tree[u];
        }
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【情况 2】查询区间与当前区间有交集但不完全覆盖
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        // 【关键】先下推懒标记！
        // 为什么？因为要访问子节点了，必须确保子节点的值是最新的
        // 如果不下推，子节点的值可能是过时的（还有待更新的修改）
        push_down(u, r - l + 1);
        
        int mid = (l + r) / 2;
        ll res = 0;
        
        // 递归查询有交集的子节点，累加结果
        if (ql <= mid) {
            // 查询区间与左子树有交集
            res += query(u * 2, l, mid, ql, qr);
        }
        
        if (qr > mid) {
            // 查询区间与右子树有交集
            res += query(u * 2 + 1, mid + 1, r, ql, qr);
        }
        
        return res;
        
        // 【query 执行过程示例】
        // 假设查询区间 [3, 6] 的和
        // 
        //                [1,8]
        //               /      \
        //           [1,4]      [5,8]
        //           /   \      /    \
        //        [1,2] [3,4] [5,6] [7,8]
        //
        // 递归路径：
        // 1. 节点 [1,8]：部分覆盖 → 递归左右子
        // 2. 节点 [1,4]：部分覆盖 → 递归右子 [3,4]
        // 3. 节点 [3,4]：完全覆盖 → 返回 tree[3,4]
        // 4. 节点 [5,8]：部分覆盖 → 递归左子 [5,6]
        // 5. 节点 [5,6]：完全覆盖 → 返回 tree[5,6]
        // 6. 最终结果 = tree[3,4] + tree[5,6]
        //
        // 只访问了 O(log n) 个节点，不需要遍历所有叶子！
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, q;
    cin >> n >> q;
    
    vector<ll> arr(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    
    SegmentTree st;
    st.n = n;
    st.build(1, 1, n, arr);
    
    for (int i = 0; i < q; i++) {
        int op;
        cin >> op;
        
        if (op == 1) {
            // 区间更新
            int l, r;
            ll val;
            cin >> l >> r >> val;
            st.update(1, 1, n, l, r, val);
        } else {
            // 区间查询
            int l, r;
            cin >> l >> r;
            cout << st.query(1, 1, n, l, r) << "\n";
        }
    }
    
    return 0;
}

/*
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║                          线段树核心要点总结                                  ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 * 
 * 【五大核心函数】
 * 
 * 1. push_up(u)：向上更新
 *    - 作用：用子节点的信息更新父节点
 *    - 时机：build 和 update 之后
 *    - 公式：tree[u] = tree[u*2] + tree[u*2+1]
 * 
 * 2. push_down(u, len)：向下推送懒标记
 *    - 作用：将父节点的懒标记传递给子节点
 *    - 时机：update 和 query 访问子节点之前
 *    - 关键：确保子节点信息是最新的
 * 
 * 3. build(u, l, r, arr)：建树
 *    - 作用：初始化线段树
 *    - 复杂度：O(n)
 *    - 方式：递归建立左右子树，然后 push_up
 * 
 * 4. update(u, l, r, ql, qr, val)：区间更新
 *    - 作用：将 [ql, qr] 区间内所有元素加上 val
 *    - 复杂度：O(log n)
 *    - 关键：完全覆盖时打标记，部分覆盖时递归子节点
 * 
 * 5. query(u, l, r, ql, qr)：区间查询
 *    - 作用：查询 [ql, qr] 区间的和
 *    - 复杂度：O(log n)
 *    - 关键：先 push_down，再递归查询子节点
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【懒标记的精髓】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 核心思想：延迟更新，避免不必要的递归
 * 
 * 工作流程：
 *   1. update 时：如果区间完全覆盖，只打标记不递归
 *   2. push_down：访问子节点前，将标记下推
 *   3. 清空标记：下推后清空父节点的标记
 * 
 * 为什么高效？
 *   - 避免每次都递归到叶子节点
 *   - 只在需要时才更新子节点
 *   - 将 O(n) 的区间更新优化为 O(log n)
 * 
 * 形象比喻：
 *   "老板（父节点）布置任务（懒标记），员工（子节点）先记着，
 *    等老板真要检查（query/update）时，员工才开始干活（push_down）。"
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【节点编号规则】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 根节点：编号 1
 * 左子节点：u << 1（即 u * 2）
 * 右子节点：(u << 1) | 1（即 u * 2 + 1）
 * 
 * 为什么 (u<<1)|1 = u*2+1？
 *   - u << 1：左移一位，相当于 u * 2（偶数）
 *   - | 1：按位或，将最低位变为 1
 *   - 偶数的最低位是 0，或上 1 就是 +1
 *   - 所以 (u<<1)|1 = u*2+1
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【位置索引】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 本实现使用 1-indexed（下标从 1 开始）
 * - 数组元素：arr[1], arr[2], ..., arr[n]
 * - 区间：[1, n]
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【空间复杂度】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 需要 4n 的空间：
 *   - 完全二叉树的节点数：最坏情况下需要 2^(⌈log₂n⌉+1) - 1 个节点
 *   - 简化为 4n 可以覆盖所有情况
 * 
 * 例如：n = 5
 *   - 完美二叉树需要 8 个叶子（2^3）
 *   - 总节点数：8 + 4 + 2 + 1 = 15 < 4*5 = 20
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【常见变体】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 1. 区间最大值/最小值
 *    - push_up: tree[u] = max/min(tree[u*2], tree[u*2+1])
 *    - 懒标记：记录区间赋值操作
 * 
 * 2. 区间乘法更新
 *    - 需要两个懒标记：lazy_mul（乘法）和 lazy_add（加法）
 *    - 下推顺序：先乘后加
 * 
 * 3. 区间赋值
 *    - 懒标记：记录赋值的目标值
 *    - 优先级：赋值 > 加法 > 乘法
 * 
 * 4. 动态开点线段树
 *    - 使用指针或动态数组
 *    - 只在需要时才创建节点
 *    - 适用于坐标范围很大但实际使用很少的情况
 * 
 * 5. 主席树（可持久化线段树）
 *    - 每次修改创建新版本
 *    - 可以查询历史版本
 *    - 空间复杂度：O(n log n)
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【提交前检查清单】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * ✓ MAXN 是否足够大（至少 4 倍输入规模）
 * ✓ push_down 的区间长度计算是否正确（len/2 和 len-len/2）
 * ✓ 懒标记是否在 push_down 后清零
 * ✓ build 函数是否正确初始化所有节点
 * ✓ update 和 query 是否处理边界情况（ql > qr）
 * ✓ 是否在访问子节点前调用 push_down
 * ✓ 是否在修改子节点后调用 push_up
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【线段树 vs 树状数组】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 树状数组：
 *   ✅ 代码简洁（10行）
 *   ✅ 常数小，速度快
 *   ✅ 空间 O(n)
 *   ❌ 只支持可逆操作（加减、异或）
 *   ❌ 不支持区间最值
 * 
 * 线段树：
 *   ✅ 功能强大，支持各种操作
 *   ✅ 区间修改 O(log n)
 *   ✅ 支持最值、GCD等
 *   ❌ 代码复杂（50+行）
 *   ❌ 常数大，空间 O(4n)
 * 
 * 选择建议：
 *   - 只需要区间和 → 树状数组
 *   - 需要区间最值/GCD → 线段树
 *   - 需要区间修改 → 线段树（带懒标记）
 */
