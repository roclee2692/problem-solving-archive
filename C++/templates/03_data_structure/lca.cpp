/*
 * 【LCA（最近公共祖先）】- 树上二分查找
 * 
 * 时间复杂度：O(n + q*log n) 使用二进制提升
 * 空间复杂度：O(n*log n)
 * 
 * 适用场景：
 *   - 树上路径长度
 *   - 两点距离
 *   - 树上位置判断
 *   - 比较节点的祖先关系
 * 
 * 模板题：
 *   - 洛谷 P3379 - 【模板】最近公共祖先（LCA）
 *   - Codeforces 519E - A and B and Lecture Rooms
 */

#include <bits/stdc++.h>
using namespace std;

const int MAXN = 5e5 + 5;
const int LOG = 20;

vector<int> adj[MAXN];  // 邻接表存储树的边

// ===== 核心数据结构：倍增数组 =====
// up[i][j] 表示节点 i 的第 2^j 个祖先
// 为什么用倍增？因为可以用二进制拆分任意跳跃步数
// 例如：跳 13 步 = 跳 2^3 步 + 跳 2^2 步 + 跳 2^0 步（13 = 1101₂）
// 这样 O(log n) 就能跳到任意祖先，而不是 O(n) 一步步跳
int up[MAXN][LOG];
int depth[MAXN];  // 记录每个节点的深度（从根节点到该节点的距离）
int n, m, s;

// ===== DFS 预处理：构建倍增表 =====
// 为什么需要 DFS？因为需要知道每个节点的父节点和深度
// 时间复杂度：O(n * log n)，因为每个节点要填 LOG 个祖先
void dfs(int u, int p) {
    // ===== 步骤 1：填充倍增表 up[u][...] =====
    // up[u][0] = p 表示 u 的第 2^0 = 1 个祖先是 p（即直接父节点）
    up[u][0] = p;
    
    // ===== 步骤 2：动态规划填充更高层的祖先 =====
    // up[u][i] = u 的第 2^i 个祖先
    // 为什么这样递推？因为跳 2^i 步 = 先跳 2^(i-1) 步，再跳 2^(i-1) 步
    // 例如：跳 2^3=8 步 = 先跳 2^2=4 步到中间节点，再从中间节点跳 2^2=4 步
    // 公式：up[u][i] = up[up[u][i-1]][i-1]
    //       ↑ u 跳 2^i 步 = u 先跳 2^(i-1) 步得到中间节点，中间节点再跳 2^(i-1) 步
    for (int i = 1; i < LOG; i++) {
        up[u][i] = up[up[u][i - 1]][i - 1];
    }
    
    // ===== 步骤 3：递归处理子树 =====
    // 为什么要 if (v != p)？防止向上回到父节点造成无限递归
    // 因为树是无向图，邻接表里父子关系是双向存储的
    for (int v : adj[u]) {
        if (v != p) {
            depth[v] = depth[u] + 1;  // 子节点深度 = 父节点深度 + 1
            dfs(v, u);  // 递归处理子节点，u 是 v 的父节点
        }
    }
}

// ===== LCA 查询：倍增算法核心 =====
// 思路：让 u 和 v 同时向上跳，直到它们的父节点相同（但不能跳过 LCA）
// 为什么分两步？因为只有深度相同时，才能同步向上跳找 LCA
int lca(int u, int v) {
    // ===== 阶段 1：调整深度对齐 =====
    // 为什么要对齐深度？因为如果深度不同，它们不可能同步向上跳到同一个节点
    // 保证 u 是深度较深的节点（如果不是就交换）
    if (depth[u] < depth[v]) swap(u, v);
    
    // ===== 用二进制拆分步数向上跳 =====
    // diff = u 比 v 深多少层
    // 为什么用二进制拆分？因为 diff 可以表示为若干个 2 的幂次之和
    // 例如：diff = 13 = 1101₂ = 2^3 + 2^2 + 2^0
    // 只需检查 diff 的每一个二进制位，如果第 i 位是 1，就跳 2^i 步
    int diff = depth[u] - depth[v];
    for (int i = 0; i < LOG; i++) {
        // (diff >> i) & 1 检查 diff 的第 i 位是否为 1
        // 为什么这样能跳到正确位置？因为二进制拆分保证了精确跳跃
        if ((diff >> i) & 1) {
            u = up[u][i];  // u 向上跳 2^i 步
        }
    }
    
    // ===== 特判：如果调整后 u == v，说明 v 就是 u 的祖先 =====
    // 为什么直接返回？因为 LCA(u, v) 就是 v 本身
    if (u == v) return u;
    
    // ===== 阶段 2：同步向上跳，逼近 LCA =====
    // 为什么从大到小枚举？因为要尽可能跳到 LCA 的下方（不能跳过 LCA）
    // 核心策略：如果 up[u][i] != up[v][i]，说明跳 2^i 步后不会相遇（还没到 LCA）
    //          那就放心跳，继续逼近 LCA
    // 为什么不相等就跳？因为相等说明已经跳到或跳过 LCA 了，不能再跳
    for (int i = LOG - 1; i >= 0; i--) {
        // 检查 u 和 v 同时跳 2^i 步后是否会相遇
        if (up[u][i] != up[v][i]) {
            // 不相遇说明 LCA 在更上方，可以跳
            u = up[u][i];
            v = up[v][i];
        }
        // 如果相等，说明跳这么大步会相遇或跳过 LCA，所以不跳，尝试更小的步长
    }
    
    // ===== 为什么最后返回 up[u][0]？=====
    // 循环结束后，u 和 v 一定停在 LCA 的直接子节点上（它们不相等但父节点相同）
    // up[u][0] 就是 u 的父节点，也就是 LCA
    // 例如：树结构为   LCA
    //                 /   \
    //                u     v
    // 此时 up[u][0] = up[v][0] = LCA
    return up[u][0];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // n 个节点，m 个查询，s 是根节点编号
    cin >> n >> m >> s;
    
    // ===== 读入树的边（n-1 条边构成树）=====
    // 为什么是 n-1 条边？因为树的定义就是 n 个节点、n-1 条边的连通无环图
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        // 无向图：u-v 和 v-u 都要存
        // 为什么双向存储？因为 DFS 时需要知道每个节点的所有邻居
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    // ===== 初始化根节点的深度和虚拟父节点 =====
    // 为什么 depth[0] = -1？因为 0 是虚拟节点（不存在的节点），作为根节点的父节点
    // 为什么需要虚拟节点？为了统一处理，避免根节点没有父节点的特殊情况
    depth[0] = -1;  // 虚拟节点深度设为 -1，这样根节点 s 的深度就是 0
    depth[s] = 0;   // 根节点深度为 0
    dfs(s, 0);      // 从根节点 s 开始 DFS，父节点是虚拟节点 0
    
    // ===== 处理 m 个 LCA 查询 =====
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        cout << lca(u, v) << "\n";  // 输出 u 和 v 的最近公共祖先
    }
    
    return 0;
}

/*
 * ========== 核心原理总结 ==========
 * 
 * 【为什么要用倍增法？】
 * 1. 暴力做法：一步步向上跳，时间复杂度 O(n)，对于 q 次查询是 O(qn)，会超时
 * 2. 倍增优化：用二进制拆分步数，任意跳 k 步只需 O(log k) 次跳跃
 *    - 例如：跳 13 步 = 跳 8 步 + 跳 4 步 + 跳 1 步（13 = 1101₂）
 *    - 预处理 O(n log n)，单次查询 O(log n)，总复杂度 O(n log n + q log n)
 * 
 * 【为什么 up[u][i] = up[up[u][i-1]][i-1] 这个递推式成立？】
 * - 数学归纳法证明：
 *   - up[u][i] 表示 u 的第 2^i 个祖先
 *   - 跳 2^i 步 = 先跳 2^(i-1) 步到达中间节点 mid = up[u][i-1]
 *   - 再从 mid 跳 2^(i-1) 步到达 up[mid][i-1]
 *   - 因为 2^(i-1) + 2^(i-1) = 2^i，所以 up[u][i] = up[up[u][i-1]][i-1]
 * 
 * 【为什么阶段 2 中"不相等才跳"？】
 * - 目标：让 u 和 v 停在 LCA 的直接子节点上（不能跳到 LCA 或跳过 LCA）
 * - 如果 up[u][i] == up[v][i]：说明同时跳 2^i 步会相遇，即 LCA 在当前位置到跳跃目标之间
 *   → 不能跳，否则会跳过 LCA
 * - 如果 up[u][i] != up[v][i]：说明同时跳 2^i 步不会相遇，LCA 在更上方
 *   → 可以跳，继续逼近 LCA
 * - 从大到小枚举保证了逼近的单调性：先跳大步粗调，再跳小步精调
 * 
 * 【为什么最后返回 up[u][0]？】
 * - 循环结束时，u 和 v 满足：
 *   1. depth[u] == depth[v]（深度相同）
 *   2. u != v（它们不是同一个节点）
 *   3. up[u][0] == up[v][0]（父节点相同）
 * - 画个图：        LCA
 *                  /   \
 *                 u     v
 * - 所以 up[u][0] 就是它们的公共父节点，即 LCA
 * 
 * 【为什么要设置虚拟节点 0？】
 * - 如果根节点没有父节点，up[root][0] 就没有定义，容易出错
 * - 设置虚拟节点 0 作为根节点的父节点，统一了边界情况的处理
 * - depth[0] = -1 保证了 depth[root] = depth[0] + 1 = 0
 * 
 * ========== 常见变体 ==========
 * - 树链剖分：支持树上路径更新，时间复杂度 O(log² n)
 * - 虚树：只保留关键节点，压缩树结构，适用于关键节点稀疏的场景
 * - Tarjan 离线 LCA：利用并查集，时间复杂度 O(n + q)，但需要离线处理
 * 
 * ========== 提交前检查 ==========
 * ✓ LOG 大小是否足够（LOG = 20 支持 2^20 > 1e6 个节点）
 * ✓ up 表初始化是否完整（DFS 要填满 up[u][0..LOG-1]）
 * ✓ DFS 遍历是否正确（要 if (v != p) 避免回到父节点）
 * ✓ depth 计算是否正确（根节点深度为 0，虚拟节点深度为 -1）
 * ✓ 树是否有根（如果是森林需要特殊处理）
 */
