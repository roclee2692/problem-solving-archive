/*
 * 【二分答案】- 将最优化问题转化为判定问题
 * 
 * 时间复杂度：O(log(ans) * check(x))
 * 空间复杂度：取决于 check 函数
 * 
 * 适用场景：
 *   - 最大化最小值 / 最小化最大值
 *   - 答案具有单调性
 *   - check 函数可以快速判断
 * 
 * 模板题：
 *   - 洛谷 P1873 - 砍树（最大化最小值）
 *   - Codeforces 279B - Books（最小化最大值）
 */

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 5;
int n, m;
int a[MAXN];

// ===== 核心：check 函数 =====
// 判断"答案为 x"是否可行
// 这是二分答案的关键！根据题目具体实现
bool check(int x) {
    // 示例：木材切割问题
    // 判断"每段长度至少为 x"能否切出 m 段
    ll cnt = 0;
    for (int i = 1; i <= n; i++) {
        cnt += a[i] / x;  // 第 i 根木头能切多少段
    }
    return cnt >= m;  // 能切出至少 m 段就可行
}

// ===== 模板 1：最大化最小值 =====
// 例如：切木头，求最大的段长
// 单调性：如果长度 x 可行，那么 < x 的都可行（找最大的可行值）
int binary_search_max() {
    int l = 1, r = 1e9;  // 答案范围 [l, r]
    int ans = 0;
    
    // ===== 二分框架：找最大的满足条件的 x =====
    while (l <= r) {
        int mid = l + (r - l) / 2;  // 防止溢出
        
        if (check(mid)) {
            // mid 可行，尝试更大的值
            ans = mid;
            l = mid + 1;
        } else {
            // mid 不可行，减小范围
            r = mid - 1;
        }
    }
    
    return ans;
}

// ===== 模板 2：最小化最大值 =====
// 例如：分配任务，求最小的最大工作量
// 单调性：如果上限 x 可行，那么 > x 的都可行（找最小的可行值）
bool check_min(int x) {
    // 示例：判断"最大工作量不超过 x"能否完成任务
    // 根据具体题目实现
    int cnt = 0, sum = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] > x) return false;  // 单个任务超过上限，不可行
        if (sum + a[i] <= x) {
            sum += a[i];
        } else {
            cnt++;  // 需要新的一天
            sum = a[i];
        }
    }
    return cnt + 1 <= m;  // 判断天数是否足够
}

int binary_search_min() {
    int l = 1, r = 1e9;
    int ans = r;
    
    // ===== 二分框架：找最小的满足条件的 x =====
    while (l <= r) {
        int mid = l + (r - l) / 2;
        
        if (check_min(mid)) {
            // mid 可行，尝试更小的值
            ans = mid;
            r = mid - 1;
        } else {
            // mid 不可行，增大范围
            l = mid + 1;
        }
    }
    
    return ans;
}

// ===== 模板 3：实数二分 =====
// 精度要求：eps = 1e-6 到 1e-9
double check_double(double x) {
    // 判断实数答案 x 是否可行
    // 例如：判断平均值是否至少为 x
    return true;  // 根据题目实现
}

double binary_search_double() {
    double l = 0.0, r = 1e9;
    const double eps = 1e-8;
    
    // ===== 实数二分：循环固定次数或精度足够 =====
    // 方法 1：循环固定次数（推荐，稳定）
    for (int i = 0; i < 100; i++) {  // 100 次足够精确到 1e-30
        double mid = (l + r) / 2;
        if (check_double(mid)) {
            l = mid;  // 最大化
        } else {
            r = mid;
        }
    }
    
    return l;
    
    // 方法 2：精度判断（有时会死循环）
    // while (r - l > eps) {
    //     double mid = (l + r) / 2;
    //     if (check_double(mid)) {
    //         l = mid;
    //     } else {
    //         r = mid;
    //     }
    // }
    // return l;
}

// ===== 模板 4：三分法（单峰函数求极值）=====
// 适用于凸函数或凹函数（只有一个极值点）
double f(double x) {
    // 目标函数，例如 f(x) = -(x-3)^2 + 5（极大值点在 x=3）
    return -(x - 3) * (x - 3) + 5;
}

double ternary_search() {
    double l = 0.0, r = 10.0;
    
    // ===== 三分法：每次缩小 1/3 范围 =====
    for (int i = 0; i < 100; i++) {
        double m1 = l + (r - l) / 3;
        double m2 = r - (r - l) / 3;
        
        if (f(m1) < f(m2)) {
            // 极值点在右半边
            l = m1;
        } else {
            // 极值点在左半边
            r = m2;
        }
    }
    
    return (l + r) / 2;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // ===== 示例：木材切割问题 =====
    // 有 n 根木头，第 i 根长度为 a[i]
    // 要切出 m 段等长木头，求最大长度
    
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    
    cout << binary_search_max() << "\n";
    
    return 0;
}

/*
 * ========== 二分答案核心原理 ==========
 * 
 * 【什么是二分答案？】
 * - 将"求最优值"转化为"判断某个值是否可行"
 * - 利用答案的单调性，用二分快速逼近最优解
 * 
 * 【识别二分答案题目的特征】
 * 1. 题目问"最大化最小值"或"最小化最大值"
 * 2. 答案具有单调性：
 *    - 如果 x 可行，那么比 x 小/大的也可行
 * 3. 可以快速判断某个值是否可行（check 函数）
 * 4. 直接求解困难，但判定容易
 * 
 * 【核心思路】
 * 原问题：求满足条件的最大/最小值
 * ↓ 转化
 * 判定问题：给定值 x，判断是否满足条件
 * ↓ 二分
 * 在 [l, r] 范围内二分答案
 * 
 * 【两种常见类型】
 * 
 * 1. 最大化最小值（找最大的可行值）
 *    - 例子：切木头问题，求最长的段
 *    - 单调性：如果长度 x 可行，< x 也可行
 *    - 策略：if (check(mid)) ans = mid, l = mid + 1
 *    - 口诀：可行就试更大的
 * 
 * 2. 最小化最大值（找最小的可行值）
 *    - 例子：分配任务，求最小的最大工作量
 *    - 单调性：如果上限 x 可行，> x 也可行
 *    - 策略：if (check(mid)) ans = mid, r = mid - 1
 *    - 口诀：可行就试更小的
 * 
 * 【check 函数设计要点】
 * 1. 明确"可行"的定义（根据题意）
 * 2. 贪心或其他快速算法判断
 * 3. 时间复杂度尽量低（总复杂度 = O(log n) × check)
 * 
 * 【整数二分 vs 实数二分】
 * 
 * | 类型 | 终止条件 | 注意事项 |
 * |------|---------|----------|
 * | 整数 | l <= r  | 用 l + (r-l)/2 防溢出 |
 * | 实数 | 循环 100 次 | 不用 r - l > eps（易死循环）|
 * 
 * 【三分法 vs 二分法】
 * - 二分：单调函数，找满足条件的点
 * - 三分：单峰函数（凸/凹），找极值点
 * - 三分原理：每次排除 1/3 不含极值的区间
 * 
 * 【经典题型】
 * 1. 最大化最小值：
 *    - 切木头（最长段）
 *    - 摆放奶牛（最大间距）
 *    - 分配巧克力（最大最小份）
 * 
 * 2. 最小化最大值：
 *    - 任务分配（最小最大工作量）
 *    - 跳石头（最小最大跳跃距离）
 *    - 图书馆借书（最小最长阅读时间）
 * 
 * 3. 实数二分：
 *    - 方程求根（精确到 1e-6）
 *    - 几何问题（最优半径、角度）
 * 
 * 4. 三分法：
 *    - 抛物线最值
 *    - 距离和最小（单峰）
 * 
 * 【常见错误】
 * 1. 单调性判断错误（搞反了最大化和最小化）
 * 2. check 函数写错（边界条件）
 * 3. 二分范围不够大（l, r 初始值）
 * 4. 实数二分用 r - l > eps 导致死循环
 * 5. 整数溢出（用 ll，mid 用 l + (r-l)/2）
 * 
 * 【调试技巧】
 * 1. 先写暴力枚举验证 check 函数
 * 2. 打印每次二分的 mid 和 check 结果
 * 3. 检查边界：l = 0 或 1？r = max(a) 还是 sum(a)？
 * 4. 小数据手模：n = 3, 答案显然时验证
 * 
 * 【提交前检查】
 * ✓ check 函数逻辑正确
 * ✓ 单调性方向正确（最大化还是最小化）
 * ✓ 二分范围足够（l, r）
 * ✓ 防止溢出（用 ll，mid 计算方式）
 * ✓ 实数二分用循环 100 次，不用 eps
 * 
 * 【竞赛考察频率】
 * - Codeforces：⭐⭐⭐⭐⭐（Div2 C/D 必考）
 * - ICPC/CCPC：⭐⭐⭐⭐（基础题型）
 * - 蓝桥杯：⭐⭐⭐（省赛常考）
 * 
 * 【与其他算法结合】
 * - 二分 + 贪心：大部分二分答案题
 * - 二分 + 前缀和：区间问题
 * - 二分 + 图论：最短路、连通性判断
 * - 二分 + DP：背包容量、最优值
 */
