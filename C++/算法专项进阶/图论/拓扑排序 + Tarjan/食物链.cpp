#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 5000 + 5, MOD = 80112002;
/**********************************************************************
 * 题型梳理 & 错题总结
 * --------------------------------------------------------------------
 * 一、带权 DAG 最短 / 最长路径类
 *    1. 题意：给定一张有向无环图，边有权，求从所有源点出发
 *       到各点的最短（或最长）距离。
 *    2. 解法：拓扑排序 + DP
 *         ┌ 对最短路：dp[] 初始化 INF，转移用  min()
 *         └ 对最长路：dp[] 初始化 0   ，转移用  max()
 *    3. 结果：通常取 dp[] 的最大 / 最小值即可，不需要计数。
 *
 * 二、食物链计数类（P4017 最大食物链计数）
 *    1. 题意：图仍是 DAG，但 *“最大食物链”* 指的是
 *       “左端无法再向左延伸、右端无法再向右延伸” 的 **所有** 路径，
 *       而不是仅最长路径。
 *       - 源点 = 入度 0 的生产者
 *       - 汇点 = 出度 0 的消费者
 *    2. 解法：拓扑排序 + 前缀计数
 *         cnt[src] = 1；其余为 0
 *         对每条拓扑边 u→v：cnt[v] += cnt[u] (mod MOD)
 *       最后把所有汇点的 cnt 累加即为答案。
 *    3. 只有一维 cnt[] 足矣；不需要记录 len[]。
 *
 * --------------------------------------------------------------------
 * 你本次踩过的坑
 * --------------------------------------------------------------------
 * 1. **混淆题意**  
 *    - 将“最大食物链”误认为“最长食物链”，错加了一维 len[]。
 *
 * 2. **边方向 & 源点选择**  
 *    - 正向存 A→B，源点应是生产者；  
 *      反向存 B→A，源点就成了消费者。  
 *    - 图方向、indegree 统计、初始化队列必须保持同一套逻辑。
 *
 * 3. **入度数组被破坏**  
 *    - 拓扑过程中直接 --indegree，若需多次调用或调试，
 *      要先备份原始 indegree。
 *
 * 4. **if 花括号遗漏**  
 *    - `if (cond) q.push(i); len[i]=0; cnt[i]=1;`
 *      实际只把第一句置于条件内，后两句每次都会执行，
 *      结果把所有节点都当成源点。
 *
 * 5. **初始化值不当**  
 *    - 最长路 dp 用 INF 初始化会让 `max()` 失效；
 *    - 计数题目中，cnt 只对源点设 1，其余为 0。
 *
 * 6. **杂项**  
 *    - 未清空 adj / topo 导致跨用例残留脏数据；  
 *    - 冗余常量 (INF, LG, Tm) 增加阅读负担；  
 *    - `return ans;` 写在 `cout` 之前导致根本不输出。
 *
 * --------------------------------------------------------------------
 * 调试建议
 * --------------------------------------------------------------------
 * • 先手画一张小图，列出入度 0 / 出度 0 节点，手算答案。  
 * • 打印关键变量：入队顺序、cnt 更新过程、最终 cnt[]。  
 * • assert 拓扑序大小 == n，快速发现环或入度统计错误。
 *********************************************************************/

ll n, m;
vector<ll> adj[N];
ll indeg[N], outdeg[N], cnt[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (ll i = 0, A, B; i < m; ++i) {
        cin >> A >> B;          // 存反向 B→A
        adj[B].push_back(A);
        ++indeg[A];
        ++outdeg[B];
    }

    queue<ll> q;
    for (ll i = 1; i <= n; ++i)   // 反向图源点 = 原图消费者
        if (!indeg[i]) { cnt[i] = 1; q.push(i); }

    while (!q.empty()) {
        ll u = q.front(); q.pop();
        for (ll v : adj[u]) {
            cnt[v] = (cnt[v] + cnt[u]) % MOD;
            if (--indeg[v] == 0) q.push(v);
        }
    }

    ll ans = 0;
    for (ll i = 1; i <= n; ++i)      // 原图生产者 = 反向图出度 0
        if (!outdeg[i]) ans = (ans + cnt[i]) % MOD;

    cout << ans << '\n';
    return 0;
}
