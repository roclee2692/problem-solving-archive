#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
// ?【术语区分】递归 Recursion / 迭代 Iteration / 递推 Recurrence

// 递归（Recursion）：
//   - 编程中函数自己调用自己。
//   - 常用于树形结构、分治、回溯等问题。
//   - 特点：调用自身，需设终止条件，否则会无限递归。

// 迭代（Iteration）：
//   - 使用循环语句（for / while）反复执行某逻辑。
//   - 每轮更新状态，直到满足结束条件。
//   - 空间效率更高，避免递归带来的栈溢出。

// 递推（Recurrence）：
//   - 数学上的推导关系，如 F(n) = F(n-1) + F(n-2)。
//   - 是数学思想，不是编程方式。
//   - 可用递归或迭代来实现递推关系。

// ?举例：斐波那契数列
//   - 递推公式：F(n) = F(n-1) + F(n-2)
//   - 可用递归实现：fib(n) = fib(n-1) + fib(n-2)
//   - 也可用迭代实现：循环从第3项推到第n项

//----------------------------------------------------------//

// ?【二分查找中的递归 vs. 迭代】优缺点比较：

// ?递归实现的优点：
//   - 写法简洁，逻辑更贴近“分治”思想。
//   - 在教学、算法入门中便于理解二分的本质。

// ?递归实现的缺点：
//   - 每次调用消耗栈空间，栈太深容易爆栈（尤其 n 很大、递归层数多）。
//   - 有函数调用的性能开销，不如迭代高效。

// ?迭代实现的优点：
//   - 性能更优，没有栈开销。
//   - 稳定可靠，适合大数据量（如 n ≥ 10^5）场景。
//   - 现代编程中更推荐使用迭代写二分查找。

// ?迭代实现的缺点：
//   - 代码稍长，可读性略低于递归，但仍容易维护。

// ?综合建议：
//   - 若无特别递归优势（如处理树结构），优先使用迭代实现二分查找。

ll binary(const vector<ll> &a,ll x){
    ll l=0;r=(ll)a.size()-1;
    while(l<=r){
        ll mid=(r+l)/2;
        if(a[mid]==x) return mid;
        else if(a[mid]<x) l=mid+1;
        else r=mid-1;        
    }
    return -1;
}

int main(){
    ios::sync_with_stdio(0);cin.tie(0);
    ll n;
    cin>>n;
    vector<ll> a(n,0);
    for(int i=0;i<n;i++){
        cin>>a[i];
    }// 输入保证升序，无需自己 sort()
    ll x;
    
    return 0;
}